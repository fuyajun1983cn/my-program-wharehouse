#+STARTUP: overview
#+STARTUP: hidestars
#+TITLE: Android学习笔记
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="css/worg.css" type="text/css" />

* 通用概念
** Android框架图
    [[./images/2016/2016071201.png]]
** Android应用程序框架
** UI基本开发
   
** Fragment
   
** 安全策略
   在Android中,安全涵盖了应用程序的部署和执行.对于部署来
   说,Android应用程序必须被赋予一个数字证书才允许被安装到某个设备中.对
   于运行来说,每个应用程序都在一个独立的应用程序中执行,每个进程都有一
   个唯一的永久的用户ID(在安装的时候分配的).

   注册应用程序需要三样东西:
   1. 一个数字证书,
   2. 一个.apk文件
   3. 以及用于将数字签名应用到.apk文件的工具(jarsigner).

   注册一个应用程序步骤如下: 

   - 使用Keytool创建一个自注册的证书.
 　　
     步骤1 Create a folder to hold the keystore, for example
     : c:\android\release\.
 　　步骤2 在命名行中执行如下命令:
     #+BEGIN_SRC sh
       　　keytool -genkey -v -keystore "FULL PATH OF release.keystore FILE FROM STEP 1"
       　　-alias androidbook -storepass paxxword -keypass paxxword -keyalg RSA
       　　-validity 14000     
     #+END_SRC

     keytool的参数说明如下：
     [[./images/2016/2016070502.png]]
     
   - 使用Jarsigner注册.apk文件
     #+BEGIN_SRC sh
       jarsigner -keystore "PATH TO YOUR release.keystore FILE" -storepass paxxword
       -keypass paxxword "PATH TO YOUR APK FILE" androidbook(别名)      
     #+END_SRC

   - 用zipalign作字节对齐
     命令如下:
     : zipalign –v 4 infile.apk outfile.apk

     验证一个.apk文件是否是4字节对齐,用如下命令
     : zipalign –c –v 4 filename.apk

   - 安装应用程序
     : adb install "PATH TO APK FILE GOES HERE"(安装)
     : adb uninstall packagename(卸载)
     : adb install –r "PATH TO APK FILE GOES HERE"(重装)
   
* Framework

** Audio System
   
*** Audio System 介绍

    [[./images/2016/2016053001.png]]
    
*** AudioTrack 介绍

    [[./images/2016/2016053002.png]]

    基本说明：
    1. 用于管理来自一个Source的Audio 播放将播放的Audio 数据送给
       AudioFlinger
    2. 提供播放的控制接口
       API:start(), stop(), ...
    3. 提供Volume 控制接口， 用于控制L/R声道各自的Volume
       - API: setVolume
       - Android 体系中有3个Audio Volume控制,  最终的输出Volume是下面3
         者的乘积 
         1. Master Volume
         2. Stream Type Volume
         3. Track Volume
    4. AudioTrack可以配置为下面三种Mode：
       1. PUSH MODE
       2. PULL MODE
       3. STATIC MODE
    5. AudioTrack测试程序
       #+BEGIN_SRC cpp
         /**
          ,* 利用AudioTrack播放一个wav文件
          ,*/

         //#define LOG_NDEBUG 0
         #define LOG_TAG "AudioTrackTest"
         //#include <utils/Log.h>
         #include <media/AudioTrack.h>
         #include <system/audio.h>
         using namespace android;
         #define ALOGD printf
         int main(int argc, char *argv[])
         {
           int readNum;
           unsigned short channel;
           unsigned int sampleRate;
           FILE *fp = fopen("bzk_chic.wav", "ab+");
           if (fp == NULL) {
             ALOGD("Cannot open .wav file");
             return -1;
           }
           ALOGD("Open wav file successfully!\n");
           fseek(fp, 0x16, 0); 
           readNum= fread(&channel, 1, 2, fp);
           if (readNum < 1) {
             ALOGD("Can not read channel number: %d\n", readNum);
             fclose(fp);
             return 0;
           }
           ALOGD("channel number is %d\n", channel);
           fseek(fp, 0x18, 0); 
           readNum = fread(&sampleRate, 1, 4, fp);
           if (readNum < 1) {
             ALOGD("Cannot read sample rate: %d\n", readNum);
             fclose(fp);
             return 0;
           }
           ALOGD("Sample Rate is %d\n", sampleRate);
           
           // playing to an AudioTrack, set up mask if necessary
           audio_channel_mask_t audioMask = AUDIO_CHANNEL_OUT_STEREO;
           if (0 == audioMask) {
             return -1;
           }
           sp<AudioTrack> audioTrack = new AudioTrack(
                                                      AUDIO_STREAM_MUSIC, sampleRate, AUDIO_FORMAT_PCM_16_BIT, audioMask,
                                                      0, AUDIO_OUTPUT_FLAG_NONE);
           status_t status = audioTrack->initCheck();
           if(status != NO_ERROR) {
             audioTrack.clear();
             ALOGD("Failed for initCheck()");
             return -1;
           }
           audioTrack->start();
           
           unsigned char *buffer = new unsigned char[channel * 64 * 2];
           while (1) {
             readNum = fread(buffer, 1, channel * 64 * 2, fp);
             if (readNum <= 0)
               break;
             ALOGD("Write data : %d to AudioTrack", readNum);
             audioTrack->write(buffer, readNum);
           }
          
           fclose(fp);
           delete []buffer;
           audioTrack->stop();
           
         }
                
       #+END_SRC

*** AudioRecord介绍

    [[./images/2016/2016053003.png]]

    基本说明：
    1. 用于管理从底层获取录音数据，并提供给上层
    2. 提供录音的控制接口
       API:start(), stop()
    3. 获取声音资料的方式
       - 由上层主动调用AudioRecord::read() 来获取数据 (PULL MODE)
       - 上层提供Callback function, 通过AudioRecord主动将资料通过
         Callback 给上层(PUSH MODE) 

*** AudioPolicyService介绍

    [[./images/2016/2016053004.png]]

    AudioPolicyService在Audio system中的位置和作用
    - 仅是一个行为决策者，而不是行为的实施者
    - 真正的实施者为AudioFlinger
    - 它是一个在后台进程中的服务实体，提供的服务就是告诉实施者要怎么去
      做

    [[./images/2016/2016053005.png]]

    AudioPolicyService几大功能:
    - 设备状态管理
    - 输入输出策略管理
    - 音量控制管理
    - Effect 控制管理

*** AudioFlinger

    [[./images/2016/2016053006.png]]

    AudioFlinger的线程循环逻辑如下所示：
    
    [[./images/2016/2016053007.png]]

** Media Framework

*** 基础知识
    AMessage代表一个消息，对应一个target， 根据这个target可以知道对
    应的消息应该归哪个AHandler去处理。

    AHandler是处理消息的基类，它有一个id，处理与这个id相关联的AMessage，
    在 =onMessageReceived= 函数中处理各种消息。
    从AHandler派生的类，都会重写该方法，以处理各种消息。

    有一个全局的 =ALooperRoster= 对象，它维护了系统中存在的 AHandler对
    象。

    ALooper对象，通过 =registerHandler= 接口将AHandler对象注册给
    =ALooperRoster= 对象维护的AHandler列表中。

*** 主要代码路径 
    
**** MediaPlayer.java
     - Java 层的 MediaPlayer 接口，APK 主要通过 call 它的接口实现播放功能
     - code path: framework/base/media/java/android/media/MediaPlayer.java

**** Media JNI
     - MediaPlayer java 层与 native 层的接口
     - code path: framework/base/media/jni/android_media_MediaPlayer.cpp
     - output:libmedia_jni.so

**** MediaPlayer
     - MediaPlayer Native 层 client 端接口
     - code path: framework/av/media/libmedia/
     - output:libmedia.so

**** Media Service
     - Native 层真正实现播放功能的 Service 进程
     - code path:
       framework/av/media/mediaserver
       framework/av/media/libmediaplayerservice
     - output: mediaserver   libmediaplayerservice.so

*** Stagefright 

**** StagefrightPlayer
     - 负责提供 player 的接口
     - code path: framework/av/media/libmediaplayerservice/StagefrightPlayer.cpp

**** AwesomePlayer
     - 真正实现 playback 功能的模块
     - code path: : framework/av/media/libstagefright

**** DataSource
     - 提供 Source 数据，可以是本地文件，也可以是网络数据
     - code path: : framework/av/media/libstagefright

**** MediaSource
     - MediaSource使用到了DataSoure和OMX，可以提供解码后的供显示的数据
     - code path: framework/av/media/libstagefright/

**** OMXClient
     - 使用 OMX 的 client 端
     - code path: framework/av/media/libstagefright/

**** OMX
     - 提供一套接口接到底层的 decoder 进行解码
     - code path: framework/av/media/libstagefright/omx

*** NuPlayer 

    [[./images/2016/2016053008.png]]
    
*** OpenMAX 
    OpenMAX is a royalty-free, cross-platform API. OpenMAX Working
    Group has been formed by the Khronos Group. The Standard for Media
    Library Portability. Reduce the cost and complexity of porting
    multimedia software to  new processors and architectures. 分为
    OpenMAX DL, IL, AL 三层，Android 上只用到 OpenMAX IL. 
    
** Graphics

*** Android Graphics Pipeline Overview
    
**** Android Graphics Pipeline

     [[./images/2016/2016052601.png]]

     如图，对于一些Buffer，有些通过GPU处理后，再送给HWComposer，有些则
     直接送给HWComposer处理。

**** BufferQueue

     [[./images/2016/2016052602.png]]

     关于BufferQueue的说明如下：
     1. manages flow of buffers between producers and consumers
     2. two queues
     3. producers dequeue unused buffers, fill them, then queue them
     4. consumers acquire filled buffers, use them, then release them
        when done.

**** SurfaceFlinger

     它的主要使用是：
     1. Responsible for compositing all windows into the display(s)
     2. Just another GL client

**** HW Composer

     一开始是为了加速叠图而准备的一个HAL，目前作为所有显示的HAL。

***** Overlay

****** Overlay 是什么
        在android 上面，屏幕上输出的画面都是由多个图层（layer）合成
        （compsing）得到的结果. 所以在android上面，图像的合成是非常普
        通而且常见(频繁)的操作, 如果有一个简单而省电的hardware(hw)来负
        责图像合成, 可以很有效的降低功耗,而且也可以降低GPU的loading.

        Overlay 就是一个专门负责图像合成的一个hw. 相比GPU 而言,
        overlay 是一个非常简单图像处理hw. 和GPU具有的庞大的图形功能不
        同, overlay只能负责简单的图像合成动作.

        由于overlay 功能简单,所以hw的实现上相比GPU也要简单很多,工作起
        来也会非常省电.

        
****** Overlay 有什么限制
        由于overlay hw很简单，所以它只能处理简单的图像合成工作，太复杂
        的图像合成工作还是要GPU来协助完成.

        overlay 无法处理的case：
        1. 需要旋转的图像
        2. 需要缩放的图像
        3. 图层超过4层

        不过对于普通的android应用场景来说,很少会出现上述的那些cases.

****** 没有overlay HW，图像合成流程
        Surfaceflinger把需要合成的layers 交给GPU 做composing, 最终输出
        到屏幕。

        [[./images/2016/2016071204.png]]

        
****** 有Overlay HW, 图像合成的流程
        Surfaceflinger把需要合成的layers 交给ovl做composing, 最终输出
        到屏幕。

        [[./images/2016/2016071205.png]]

****** 有overlay HW,但需要GPU做图像合成流程
        Overlay不能处理的layers, 会交给GPU做图像合成，GPU把图像合成为
        一个layer, 然后再通过overlay 输出.

        [[./images/2016/2016071206.png]]

*** Android Sync Framework

**** 定义

     Synchronization between consumers and producers who are from
     different hardware components to use a buffer atomically

**** 应用背景

     在复杂的DMA管线如图形管线（多媒体，摄像头，GPU以及显示设备），一
     个buffer的消费者需要知道生产者什么时候完成生产（即创建一个Buffer,
     并往里面放置消费者所需要的数据）。同样地，生产者也需要知道消费者
     什么时候使用它创建的Buffer，以便它可以重新使用这个Buffer。而且，
     一个Buffer可能被多个不同的消费者使用不同的时间。另外，一个消费者
     可能需要互斥地消费多个Buffer，等等，有一个问题应运而生，就是如何
     保证多个消费者之间同步使用Buffer，以及生产者与消费者协调使用
     Buffer。因为Buffer是一个共享资源，且任何消费者或生产者对Buffer的
     使用都是排他性的（因为它们属于不同的硬件单元或模块），大体看来，
     需要解决如下两个问题：
     1. 消费者与生产者之间对Buffer的同步访问。
     2. 消费者之间对Buffer的同步访问。
     
**** 目标

     1. Provide a simple API to let components signal when buffers are
        ready/released.
     2. Allow synchronization primitives to be passed between processes
        and between userspace and the kernel.
     3. Allow implementers to exploit hardware sync support
     4. Provide visibility into the graphics pipeline for debugging

**** Software Stacks

     [[./images/2016/2016052609.png]]

**** 实现 

     1. sync_timeline

        [[./images/2016/2016052603.png]]

        - Represents monotonically increasing counter

        - Generally one instance per driver context

        - allows hardware specific implementation

        - sw_sync implementation provided

     2. sync_pt

        [[./images/2016/2016052604.png]]

        - Represents a specific values on a parent timeline

        - 3 states
          - active

          - signaled

          - error

        - starts active and transitions once to either signaled or
          error

     3. sync_fence

        [[./images/2016/2016052605.png]]

        - A collection of sync_pts

        - Backed by a file and can be passed to userspace.

        - Main primitive drivers and userspace use to describe sync
          events/dependencies.

        - Fences are a promise by the kernel
          - that work has been queued

          - and will complete in a "timely" manner

        - Starts active and transitions to signaled with all of its
          sync_pts become signaled or one becomes errored

        - The list of sync_pts is immutable after fence creation

        - A sync_pt can only be in one fence.

        - Two fences can be merged to create a third fence containing
          copies of the sync points in both.

        - Sync Merge

          - Before Merge

            [[./images/2016/2016052606.png]]

          - After Merge

            [[./images/2016/2016052607.png]]

     4. 代码

        - supported in android-3.10 kernel + staged for quite some
          time

        - Core

          - =drivers/staging/android/sync.c=

          - =drivers/staging/android/sync.h=

        - sw_sync
          
          - =drivers/staging/android/sw_sync.c=

          - =drivers/staging/android/sw_sync.h=

        - 接口声明

          [[./images/2016/2016052608.png]]

     5. 实现sync_timeline的建议

        在实现前，先考虑是否可以直接使用sw_sync, 以sw_sync为起点。
        - Don'ts
          - Don't base a timeline on any "real" time.

          - Don't allow userspace to explicitly
            - create a fence

            - signal a fence

          - Don't access sync_timeline, sync_pt, or sync_fence
            elements explicitly.

        - Dos
          - Do provide useful names

          - Do implement timeline_value str and pt_value_str

          - Do implement fill driver_data

** Input System

   Input  Event Process Flow

   [[./images/2016/2016053009.png]]

   
*** Architecture (ICS)

    [[./images/2016/2016053010.png]]

*** Architecture (JB)

    [[./images/2016/2016053011.png]]

** Wifi Framework

*** 传统WiFi
    Android Framework中的wifi代码分为两部分，一部分面向应用开发者，提供
    公共接口给应用开发者，另一部分则是框架的实现灵魂，代码分别位于：
    Android 5.1
    - frameworks\base\wifi\java\android\net\wifi
    - frameworks\opt\net\wifi\service

**** WifiConfigStore

**** Scan周期
        =config_wifi_supplicant_scan_interval=  
        =config_wifi_framework_enable_associated_autojoin_scan=  关联
        后是否允许扫描

*** P2P/Miracast
    
**** 开启WifiSink的调用序列
     DisplayManager.requestEnableSink
     DisplayManager.enableSink
     DisplayManagerGlobal.enableSink
     DisplayManagerService.enableSink
     DisplayManagerService.enableSinkInternal
     WifiDisplayAdapter.requestEnableSinkLocked
     WifiDisplayController.requestEnableSink


     WifiDisplaySinkActivity
     WfdSinkSurfaceFragment
     WfdSinkExt.setupWfdSinkConnection
     WfdSinkExt.setWfdMode(true)
     WifiDisplayAdapter.requestEnableSinkLocked
     ...
     WifiDisplayController.startWaitConnection
     WifiDisplayController.enterSinkState


** Global Settings
   设置和访问一个全局变量。
   
*** Settings.java
    #+BEGIN_SRC java
      //frameworks/base/core/java/android/provider/Settings.java
      public final class Settings {
          public static final String WIFI_AUTO_CONNECT = "wifi_auto_connect";
          ...
          MOVED_TO_GLOBAL.add(Settings.Global.WIFI_AUTO_CONNECT);
      }
    #+END_SRC

*** defaults.xml
    #+BEGIN_SRC xml
      <!-- /packages/SettingsProvider/res/values/defaults.xml -->
      <integer name="def_wifi_auto_connect">0</integer>
    #+END_SRC

*** DatabaseHelper.java
    #+BEGIN_SRC java
      public class DatabaseHelper extends SQLiteOpenHelper {
          ...
          loadIntegerSetting(stmt, Settings.Global.WIFI_AUTO_CONNECT,
                             R.integer.def_wifi_auto_connect);

          ...
      }
    #+END_SRC

*** 访问
    #+BEGIN_SRC java
      //读取
      Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WIFI_AUTO_CONNECT);
      //写入
      Settings.Global.putInt(getContentResolver(), Settings.Global.WIFI_AUTO_CONNECT, 0);
                             
    #+END_SRC





         










* 我的技术文摘

** 编写native activity
   =android/native_activity.h= 提供的本地活动接口是基于应用程序提供的
   一系列回调函数, 这些回调函数将在相应事件发生，在活动的主线程中调用，
   所以这些回调函数不能阻塞。

   理论上，我们只要编写相应的回调函数就可以了，方法简单， 直接了当，但
   是，非常受限（因为在主线程中直接执行，会阻塞主线程）。为了解决这种
   限制， *NDK* 包中提供了 =android_native_app_glue= 库，采用多线程方式，允许
   应用程序在不同的线程上实现自己的主事件循环，它的要求如下：
   1. 应用程序必须提供一个称为 =android_main()= 的函数，它将在活动创建时
      被调用。它是单独开启一个线程执行的，不在活动的主线程里面。
   2. =android_main()= 接受一个合法的 =android_app= 结构体指针，它包含
      了对其他重要对象的引用，如应用程序运行于其中的ANativeActivity对
      象实例。
   3. =android_app= 对象拥有一个ALooper实例，它已经监听了两个重要的事件：
      * 活动生命周期事件（如“暂停”，“恢复”）。
        : ALooper_pollOnce：LOOPER_ID_MAIN
      * 来自于依附于当前活动的AInputQueue的事件。
        : ALooper_pollOnce：LOOPER_ID_INPUT
        可以监听发生在其他的文件描述符上的事件，可以使用回调方式或设置
        indent值为 =LOOPER_ID_USER= 
        : ALooper_addFd（...）
   4. 任何时候，收到 =LOOPER_ID_MAIN= 或 =LOOPER_ID_INPUT= 事件，返回的数
      据是一个指向 =android_poll_source= 的结构体指针。可以调用它的 =process()=
      函数，并在其中回调 =android_app->onAppCmd= 和 =android_app->onInputEvent=
      处理应用程序相关的事件。当然，也可以调用底层的函数直接读取和处理
      数据。

      #+CAPTION: 函数调用序列图
      [[./images/2016/2016070501.png]]

** Binder通信过程中的结点管理

    BpBinder类代表一个远程Binder对象（继承自BpRefBase）的通信功能部分。
    它提供了linkToDeath方法，供其他对象监听自己所关联的本地结点的死亡
    通知，本质上是通过调用IPCThreadState类的requestDeathNotification接
    口。unlinkToDeath方法则是取消接收Binder结点的死亡通知。而
    sendObituary则是向监听者发送结点的死亡通知。这两个接口都会通过
    IPCThreadState类的clearDeathNotification将消息处理发送到Binder驱动
    去处理。

    一般BpBinder对象是包含于从BpRefBase继承过来的类中，也即BpINTERFACE
    类的一个私有成员，代表IPC通信的一方与另一方进行通信。在Binder驱动，
    要支持死亡通知机制，是通过 =binder_ref= 来实现的。 =binder_ref= 有一个成员
    是指向 =struct binder_ref_death= 结构的指针。它的结构定义如下：
    #+BEGIN_SRC c
      struct binder_ref_death {
              struct binder_work work;
              binder_uintptr_t cookie;
      };
    #+END_SRC

    其中，work是指提交给当前线程或进程处理的工作类型，一般为如下三种：
    #+BEGIN_SRC c
      BINDER_WORK_DEAD_BINDER, //dead binder
      BINDER_WORK_DEAD_BINDER_AND_CLEAR, //clear dead binder
      BINDER_WORK_CLEAR_DEATH_NOTIFICATION, //clear death notification
    #+END_SRC

    cookie则一般保存的是BpBinder对象的内存地址，主要用于标识当前的通信
    会话。

    *linkToDeath(…)接口代码分析*  

    该接口的原型如下：
    #+BEGIN_SRC c++
      virtual status_t    linkToDeath(const sp<DeathRecipient>& recipient,
                                          void* cookie = NULL,
                                          uint32_t flags = 0);
    #+END_SRC

    使用示例如下，SurfaceFlinger将监听window manager进程的死亡消息：
    #+BEGIN_SRC c++
      void SurfaceFlinger::bootFinished()
      ｛
              。。。
          // wait patiently for the window manager death
          const String16 name("window");
          sp<IBinder> window(defaultServiceManager()->getService(name));
          if (window != 0) {
              window->linkToDeath(static_cast<IBinder::DeathRecipient*>(this));
          }
              。。。
      ｝    
    #+END_SRC

    下面看下linkToDeath方法调用的流程：
    #+BEGIN_SRC plantuml :exports both :file ./images/2016/2016072801.png :cmdline -charset UTF-8
      @startuml
      [ -> BpBinder: linkToDeath
      BpBinder -> IPCThreadState: requestDeathNotification
      IPCThreadState -> Binder Driver: BC_REQUEST_DEATH_NOTIFICATION
      @enduml
    #+END_SRC

    下面看下处理 =BC_REQUEST_DEATH_NOTIFICATION= 的代码逻辑：
    
    由于requestDeathNotification方法传入的两个参数一个是远程Binder结点
    的句柄以及对象本身的内存地址（BpBinder对象），所以驱动依次拿到这两
    个参数：

    #+BEGIN_SRC c
      int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                              binder_uintptr_t binder_buffer, size_t size,
                              binder_size_t *consumed)
      {
        …
       case BC_REQUEST_DEATH_NOTIFICATION:
       case BC_CLEAR_DEATH_NOTIFICATION: {
         uint32_t target;
         binder_uintptr_t cookie;
         struct binder_ref *ref;
         struct binder_ref_death *death;

         if (get_user(target, (uint32_t __user *)ptr))
           return -EFAULT;
         ptr += sizeof(uint32_t);
         if (get_user(cookie, (binder_uintptr_t __user *)ptr))
           return -EFAULT;
         ptr += sizeof(binder_uintptr_t);
         //其中通过第一个参数在当前进程找到对应的binder_ref实例，
           ref = binder_get_ref(proc, target);

           //下面是处理BC_REQUEST_DEATH_NOTIFICATION的代码：

           if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
             如果ref->death不为空，则说明之前已经调用过requestDeathNotification，直接忽略这次调用。
               if (ref->death) {
                 binder_user_error("%d:%d BC_REQUEST_DEATH_NOTIFICATION death notification already set\n",
                                   proc->pid, thread->pid);
                 break;
               }
             //否则，则创建一个binder_ref_death实例，并绑定给上述的binder_ref实例。
               death = kzalloc(sizeof(*death), GFP_KERNEL);
             if (death == NULL) {
               thread->return_error = BR_ERROR;
               binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,
                            "%d:%d BC_REQUEST_DEATH_NOTIFICATION failed\n",
                            proc->pid, thread->pid);
               break;
             }
             binder_stats_created(BINDER_STAT_DEATH);
             INIT_LIST_HEAD(&death->work.entry);
             death->cookie = cookie;
             ref->death = death;
             //如果远程Binder结点所在的进程已经退出，则说明远程Binder结点已经死亡，应该发送死亡通知，是通过与之关联的binder_ref的死亡列表发送通知的。
               if (ref->node->proc == NULL) {
                 ref->death->work.type = BINDER_WORK_DEAD_BINDER;
                 // 如果当前线程没有退出，就发送到线程的事件处理链表中，否则发送到进程的事件处理链表中。
                   if (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                     list_add_tail(&ref->death->work.entry, &thread->todo);
                   } else {
                     list_add_tail(&ref->death->work.entry, &proc->todo);
                     wake_up_interruptible(&proc->wait);
                   }
               }
           }
           //这里说明下，当ref->death->work.entry链表为空，说明binder_ref关联的远程Binder结点还处于活跃状态，无需发送死亡通知。
          
    #+END_SRC
    
    *unlinkToDeath(…)* 

   #+BEGIN_SRC plantuml :exports both :file ./images/2016/2016072802.png :cmdline -charset UTF-8
      @startuml
      [ -> BpBinder: unlinkToDeath
      BpBinder -> IPCThreadState: clearDeathNotification
      IPCThreadState -> Binder Driver: BC_CLEAR_DEATH_NOTIFICATION
      @enduml
    #+END_SRC
    
    下面来看处理 =BC_CLEAR_DEATH_NOTIFICATION= 的逻辑。

    发出这个命令的情形有两种：
    1. 结点没有死亡，此时提交的工作类型为
       =BINDER_WORK_CLEAR_DEATH_NOTIFICATION= ，只是取消监听结点的死亡通知，
       不影响其他对象对该结点的监听。
    2. 结点已经死亡，此时提交的工作类型为
       =BINDER_WORK_DEAD_BINDER_AND_CLEAR= ，
       这时是要清除。

       #+BEGIN_SRC c
         int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread,
                                 binder_uintptr_t binder_buffer, size_t size,
                                 binder_size_t *consumed)
         {
           …
          case BC_REQUEST_DEATH_NOTIFICATION:
          case BC_CLEAR_DEATH_NOTIFICATION: {
            …
              if (cmd == BC_REQUEST_DEATH_NOTIFICATION) {
                …
                  } else {
                if (ref->death == NULL) {
                  binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification not active\n",
                                    proc->pid, thread->pid);
                  break;
                }
                death = ref->death;
                //通过cookie来标识当前通信会话
                  if (death->cookie != cookie) {
                    binder_user_error("%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification cookie mismatch %016llx != %016llx\n",
                                      proc->pid, thread->pid,
                                      (u64)death->cookie, (u64)cookie);
                    break;
                  }
                ref->death = NULL;
                // ''如果death->work.entry为空，说明被监听的Binder结点还处于活跃状态，这时只是取消对该结点的死亡监听
                  if (list_empty(&death->work.entry)) {
                    death->work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
                    if (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                      list_add_tail(&death->work.entry, &thread->todo);
                    } else {
                      list_add_tail(&death->work.entry, &proc->todo);
                      wake_up_interruptible(&proc->wait);
                    }
                  } else {
                    //  否则，该结点已经死亡，将当前工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR
                      BUG_ON(death->work.type != BINDER_WORK_DEAD_BINDER);
                    death->work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;
                  }
              }

            …
              }
                
       #+END_SRC

       如下是处于当前线程或进程上的 =binder_work= 的处理过程：
       #+BEGIN_SRC c
         static int binder_thread_read(struct binder_proc *proc,
                                       struct binder_thread *thread,
                                       binder_uintptr_t binder_buffer, size_t size,
                                       binder_size_t *consumed, int non_block)
         {
           …
             while (1) {
               …
                 //从当前线程或进程中取出提交上来的工作类型
                 if (!list_empty(&thread->todo))
                   w = list_first_entry(&thread->todo, struct binder_work, entry);
                 else if (!list_empty(&proc->todo) && wait_for_proc_work)
                   w = list_first_entry(&proc->todo, struct binder_work, entry);
                 else {
                   …
                     }
               …
                 switch (w->type) {
                   …
                 case BINDER_WORK_DEAD_BINDER:
                 case BINDER_WORK_DEAD_BINDER_AND_CLEAR:
                 case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: {
                   struct binder_ref_death *death;
                   uint32_t cmd;

                   death = container_of(w, struct binder_ref_death, work);
                   if (w->type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)
                     //被监听的结点没有死亡，通知用户空间减少对该结点的弱引用计数
                       cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;
                   else
                     //被监听的结点已经死亡，发送BR_DEAD_BINDER通知用户空间处理
                       cmd = BR_DEAD_BINDER;
                   if (put_user(cmd, (uint32_t __user *)ptr))
                     return -EFAULT;
                   ptr += sizeof(uint32_t);
                   if (put_user(death->cookie,
                                (binder_uintptr_t __user *)ptr))
                     return -EFAULT;
                   ptr += sizeof(binder_uintptr_t);
                   binder_stat_br(proc, thread, cmd);
                   binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,
                                "%d:%d %s %016llx\n",
                                proc->pid, thread->pid,
                                cmd == BR_DEAD_BINDER ?
                                "BR_DEAD_BINDER" :
                                "BR_CLEAR_DEATH_NOTIFICATION_DONE",
                                (u64)death->cookie);

                   if (w->type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) {
                     //这种情况是要删除death实例
                       list_del(&w->entry);
                     kfree(death);
                     binder_stats_deleted(BINDER_STAT_DEATH);
                   } else
                     // 将death实例的清理工作，提交到进程中延后处理（在收到BC_DEAD_BINDER_DONE时处理）
                       list_move(&w->entry, &proc->delivered_death);
                   //由于BR_DEAD_BINDER还要触发用户空间向Binder驱动发送后续命令BC_CLEAR_DEATH_NOTIFICATION， BC_DEAD_BINDER_DONE， 所以应当退出当前循环，以便当前线程能够处理上述命令。
                     if (cmd == BR_DEAD_BINDER)
                       goto done; /* DEAD_BINDER notifications can cause transactions */
                 } break;
                 }
               …
                 }
                
       #+END_SRC

       如果在requestDeathNotification的时候结点已经退出，或Binder通信
       结束，Binder结点被释放，调用了 =binder_node_release= ，驱动会返回
       =BR_DEAD_BINDER= 命令，通知上层处理。
       #+BEGIN_SRC c++
         status_t IPCThreadState::executeCommand(int32_t cmd)
         ｛
                 。。。
             case BR_DEAD_BINDER:
                 {
                     BpBinder *proxy = (BpBinder*)mIn.readInt32();
                     proxy->sendObituary();
                     mOut.writeInt32(BC_DEAD_BINDER_DONE);
                     mOut.writeInt32((int32_t)proxy);
                 } break;
                 。。。
         ｝
                
       #+END_SRC

       首先，代表远程结点通信的BpBinder会调用sendObituary命令，清除对
       它的死亡通知列表（会向驱动发送 =BC_CLEAR_DEATH_NOTIFICATION= 命
       令），并调用监听者的回调函数通知监听者。之后，会向驱动发送
       =BC_DEAD_BINDER_DONE= ，通知驱动善后处理。

      下面看下 =BC_DEAD_BINDER_DONE= 的处理过程：
       #+BEGIN_SRC c
          case BC_DEAD_BINDER_DONE: {
            struct binder_work *w;
            binder_uintptr_t cookie;
            struct binder_ref_death *death = NULL;
            if (get_user(cookie, (binder_uintptr_t __user *)ptr))
              return -EFAULT;

            ptr += sizeof(void *);
            //从当前进程的延迟处理列表中，取出要处理的工作类型
              list_for_each_entry(w, &proc->delivered_death, entry) {
              struct binder_ref_death *tmp_death = container_of(w, struct binder_ref_death, work);
              //通过cookie来新知识对应的binder_ref_death实例
                if (tmp_death->cookie == cookie) {
                  death = tmp_death;
                  break;
                }
            }
            binder_debug(BINDER_DEBUG_DEAD_BINDER,
                         "%d:%d BC_DEAD_BINDER_DONE %016llx found %p\n",
                         proc->pid, thread->pid, (u64)cookie, death);
            //如果相关信息无法找到，则直接退出，无需后续处理
              if (death == NULL) {
                binder_user_error("%d:%d BC_DEAD_BINDER_DONE %016llx not found\n",
                                  proc->pid, thread->pid, (u64)cookie);
                break;
              }
                                 
            list_del_init(&death->work.entry);
            //结点已经死亡，需要清理消息通知相关信息
              if (death->work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) {
                death->work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;
                if (thread->looper & (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) {
                  list_add_tail(&death->work.entry, &thread->todo);
                } else {
                  list_add_tail(&death->work.entry, &proc->todo);
                  wake_up_interruptible(&proc->wait);
                }
              }
          } break;
                
       #+END_SRC

       *IPC通信过程示例*

       #+BEGIN_EXAMPLE
         BC_DEAD_BINDER(binder_node_release或BC_REQUEST_DEATH_NOTIFICATION)
         ->BR_DEAD_BINDER(binder_thread_read)
         -> BC_CLEAR_DEATH_NOTIFICATION（如果结点已经死亡，则工作类型修改为BINDER_WORK_DEAD_BINDER_AND_CLEAR）
         -> BC_DEAD_BINDER_DONE（将工作类型修改为BINDER_WORK_CLEAR_DEATH_NOTIFICATION，提交到当前线程或进程进一步处理）
         -> BR_CLEAR_DEATH_NOTIFICATION_DONE       
       #+END_EXAMPLE

** Looper类代码分析
   　　本文将分析一下Looper类的实现及其应用，代码位于
   frameworks/native/lib/utils/Looper.cpp。主要分为如下几个部分：
   1. epoll系统调用接口简介
   2. Looper类代码分析
   3. Looper类应用实例分析

   *一、epoll系统调用接口简介*

   Looper事件机制实际上是依赖系统调用epoll实现的。它是一种I/O复用模型，
   即可以同时监控多个I/O事件。对于Looper来说，所谓的I/O事件就是所监控
   的文件描述符上没有有数据到达。epoll的主要接口如下所示 ：
   1. =epoll_create()=
      创建一个epoll实例，返回引用该实例的文件描述符。
      原型如下所示 ：
      : int epoll_create(int size );
      参数size指定了我们想通过epoll实例监控文件描述符的数量。
   2. =epoll_ctl()=
      　　操作与该epoll实例相关联的兴趣列表：添加一个文件描述符到兴趣
      列表中，从兴趣列表中删除一个现存的文件描述符以及修改事件掩码以决
      定要监控文件描述符上发生的哪个事件。
      原型如下所示：
      : int epoll_ctl(int epfd , int op , int fd , struct epoll_event * ev );

      其中参数op可以取如下一些值：
      |---------------+--------------------------|
      | EPOLL_CTL_ADD | 将fd加入了监控列表       |
      |---------------+--------------------------|
      | EPOLL_CTL_MOD | 修改当前监控的fd相关信息 |
      |---------------+--------------------------|
      | EPOLL_CTL_DEL | 将fd从监控列表中删除     |
      |---------------+--------------------------|
   3. =epoll_wait()=
      从I/O Ready列表中返回与epoll实例相关联的项，即返回有事件发生的文
      件描述符的数量。
      原型如下所示：
      : int epoll_wait(int epfd , struct epoll_event * evlist , int maxevents , int timeout );
      其中timeout值为-1时，表示无限等待直到有事件发生。为0时，执行一个
      非阻塞检查后立即返回。大于0时，表示一个超时时间值。

      另外， =struct epoll_event= 结构定义如下所示 ：
      #+BEGIN_SRC c
        struct epoll_event {
            uint32_t events;  /* epoll events (bit mask) */
            epoll_data_t data; /* User data */
        };      
      #+END_SRC

      主要的事件掩码有：
      EPOLLIN：代表有数据可读
      EPOLLOUT：代表有数据可写

      =epoll_data_t= 的数据结构定义如下：
      #+BEGIN_SRC c
        typedef union epoll_data {
            void *ptr;  /* Pointer to user-defined data */
            int fd;  /*File descriptor */
            uint32_t u32; /* 32-bit integer */
            uint64_t u64; /* 64-bit integer */
        } epoll_data_t;      
      #+END_SRC

      使用实例:
      #+BEGIN_SRC c
        int epfd;
        struct epoll_event ev;
        epfd = epoll_create(5);
        if (epfd == -1)
            errExit("epoll_create");
        ev.data.fd = fd;
        ev.events = EPOLLIN;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1)
            errExit("epoll_ctl");
        ...
        epoll_wait(...);      
      #+END_SRC

   *二、Looper类代码分析*

   Looper类定义了一种事件接口，这里所谓的事件就是文件描述符上的I/O数据
   是否可读或可写。它提供了一系列接口来支持事件通知和响应，通过轮询，
   利用epoll系统调用，可以侦测到发生在文件描述符上的I/O事件。

   在分析Looper类之前，我们先来看两个与之相关的接口：
   1. Looper消息处理接口。
      #+BEGIN_SRC c
        class MessageHandler : public virtual RefBase {
        protected:
            virtual ~MessageHandler() { }

        public:
            /**
             ,* Handles a message.
             ,*/
            virtual void handleMessage(const Message& message) = 0;
        };      
      #+END_SRC

      与之相关的Looper类的几个成员函数定义如下：
      #+BEGIN_SRC c
            /**
             ,* Enqueues a message to be processed by the specified handler.
             ,*/
            void sendMessage(const sp<MessageHandler>& handler, const Message& message);

            /**
             ,* Enqueues a message to be processed by the specified handler after all pending messages
             ,* after the specified delay.
             ,*/
            void sendMessageDelayed(nsecs_t uptimeDelay, const sp<MessageHandler>& handler,
                    const Message& message);

            /**
             ,* Enqueues a message to be processed by the specified handler after all pending messages
             ,* at the specified time.
             ,*/
            void sendMessageAtTime(nsecs_t uptime, const sp<MessageHandler>& handler,
                    const Message& message);

            /**
             ,* Removes all messages for the specified handler from the queue.
             ,*/
            void removeMessages(const sp<MessageHandler>& handler);

            /**
             ,* Removes all messages of a particular type for the specified handler from the queue.
             ,*/
            void removeMessages(const sp<MessageHandler>& handler, int what);
              
      #+END_SRC

      　　从上述成员函数的定义可以看到，Looper对MessageHandler都拥有强
      引用，所以需要通过显式调用remoeveMessage将其删掉。

      　　此外，也定义了一个WeakMessageHandler类，它通过一个弱引用来引
      用一个MessageHandler对象，在需要的时候强化为强引用。

   2. Looper回调函数接口。
      回调函数类定义如下：
      #+BEGIN_SRC c
        /**
         ,* A looper callback.
         ,*/
        class LooperCallback : public virtual RefBase {
        protected:
            virtual ~LooperCallback() { }

        public:
            /**
             ,* Handles a poll event for the given file descriptor.
             ,* It is given the file descriptor it is associated with,
             ,* a bitmask of the poll events that were triggered (typically ALOOPER_EVENT_INPUT),
             ,* and the data pointer that was originally supplied.
             ,*
             ,* Implementations should return 1 to continue receiving callbacks, or 0
             ,* to have this file descriptor and callback unregistered from the looper.
             ,*/
            virtual int handleEvent(int fd, int events, void* data) = 0;
        };      
      #+END_SRC

      同样地，也定义了一个辅助类SimpleLooperCallback，它支持接受一个回
      调函数指针。
      : typedef int (*ALooper_callbackFunc)(int fd, int events, void* data);

      与之相关的Looper类的成员函数如下所示 ：
      : int addFd(int fd, int ident, int events, ALooper_callbackFunc callback, void* data);
      : int addFd(int fd, int ident, int events, const sp<LooperCallback>& callback, void* data);

      　　这两个成员函数的主要作用是：将要监控的fd加入到Looper的事件监
      控列表中。这里，可以指定回调函数。当有事件发生时，Looper实例会自
      动调用回调函数。如果回调函数为空，则由调用者处理发生的事件。

      　　下面将分析Looper类的实现。先分析下成员变量的意义：

      #+BEGIN_SRC c++
        const bool mAllowNonCallbacks; // immutable

        int mWakeReadPipeFd;  // immutable
        int mWakeWritePipeFd; // immutable
        Mutex mLock;

        Vector<MessageEnvelope> mMessageEnvelopes; // guarded by mLock
        bool mSendingMessage; // guarded by mLock

        int mEpollFd; // immutable

        // Locked list of file descriptor monitoring requests.
        KeyedVector<int, Request> mRequests;  // guarded by mLock

        // This state is only used privately by pollOnce and does not require a lock since
        // it runs on a single thread.
        Vector<Response> mResponses;
        size_t mResponseIndex;
        nsecs_t mNextMessageUptime; // set to LLONG_MAX when none      
      #+END_SRC

      　　它们的表示的意义如下所示:
      　　mAllowNonCallbacks: 表示是否允许将文件描述符加入监控对象时，
      指定回调函数为空。

      　　mWakeReadPipeFd：Looper类默认构造的双向管道的只读端。
      
      　　mWakeWritePipeFd：Looper类默认构造的双向管道的只写端。

          mLock：互斥访问保护锁，主要Looper类的一些成员变量的并发访问。

      　　mMessageEnvelopes：Looper实例包含的“消息信封”集合。消息信封
      主要包含如下属性：时间戳，消息处理函数指针以及消息本身。

      　　mSendingMessage：当前Looper实例是否正在发送消息。

      　　mEpollFd：epoll实例对应的描述符。

      mRequests：当前Looper实例中的文件描述符监控请求。对就的数据结构
      struct Request定义如下：

      #+BEGIN_SRC c
        struct Request {
          int fd;
          int ident;
          sp<LooperCallback> callback;
          void* data;
        };      
      #+END_SRC

      其中，fd表示监控的文件描述符，ident表示表示监控的事件标识。
      callback是事件发生时，对应的回调函数。data为传递给回调函数的自定
      义数据。

      mResponses：当前的响应集合。数据结构Response的定义如下：

      #+BEGIN_SRC c
        struct Response {
          int events;
          Request request;
        };      
      #+END_SRC

      mResponseIndex：响应索引号。

      mNextMessageUptime：下一个消息处理的时间。

      　　接下来，看构造函数声明：
      : Looper(bool allowNonCallbacks);

      　　参数allowNonCallbacks表示是否允许将文件描述符加入监控对象时，
      指定回调函数为空。

      　　其实现如下所示：
      　　首先，它创建了一个双向管道，一端读，一端写。并将其设置为非阻
      塞模式。然后创建epoll实例，将只读端管道文件描述符中入到epoll的监
      控列表中，这样保护epoll实例中至少包含有一个文件描述符在其事件监
      控列表中。详细代码如下所示 ：

      #+BEGIN_SRC c++
        Looper::Looper(bool allowNonCallbacks) :
          mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),
          mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {
          int wakeFds[2];
          int result = pipe(wakeFds);
          LOG_ALWAYS_FATAL_IF(result != 0, "Could not create wake pipe.  errno=%d", errno);

          mWakeReadPipeFd = wakeFds[0];
          mWakeWritePipeFd = wakeFds[1];

          result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
          LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake read pipe non-blocking.  errno=%d",
                              errno);

          result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
          LOG_ALWAYS_FATAL_IF(result != 0, "Could not make wake write pipe non-blocking.  errno=%d",
                              errno);

          // Allocate the epoll instance and register the wake pipe.
          mEpollFd = epoll_create(EPOLL_SIZE_HINT);
          LOG_ALWAYS_FATAL_IF(mEpollFd < 0, "Could not create epoll instance.  errno=%d", errno);

          struct epoll_event eventItem;
          memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
          eventItem.events = EPOLLIN;
          eventItem.data.fd = mWakeReadPipeFd;
          result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);
          LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake read pipe to epoll instance.  errno=%d",
                              errno);
        }      
      #+END_SRC

      　　再来看与线程相关的几个类的静态函数：
      : static sp<Looper> prepare(int opts);
      　　将一个Looper实例与调用者所在的线程关联。Opts的值为： 
      　　 =ALOOPER_PREPARE_ALLOW_NON_CALLBACKS= 或0，它返回该Looper实
      例。

      : static void setForThread(const sp<Looper>& looper);
      设置looper对象与当前线程关联。如果当前looper对象已经存在，则替换
      掉。如果looper为NULL，则删除当前关联的looper对象。

      : static sp<Looper> getForThread();
      　　返回当前线程关联的Looper实例。

      接下来看下两个比较重要的成员函数：
      : int Looper::addFd(int fd, int ident, int events, const sp<LooperCallback>& callback, void* data)
      该函数主要是将fd加入到Looper的事件监控列表中。如果
      allowNonCallbacks为false，则必须指定回调函数，且此时ident值为
      =ALOOPER_POLL_CALLBACK(-2)= ，忽略传入的indent的值，而回调函数为空
      时，传入的ident值不能小于0 。实际上会通过系统调用epoll_ctl将fd加
      入到epoll实例的事件监控列表中。同时，也记录下此次的监控信息，封
      装成一个Request实例，加入到成员变量mRequests当中。如果fd已经存在，
      则替换掉旧的Request对象。

      : void Looper::sendMessageAtTime(nsecs_t uptime, const sp<MessageHandler>& handler, const Message& message) 
      该函数主要作用就是发送一个Message对象，实现就是注册一个
      MessageEnvelop（消息信封）实例，加入到成员变量mMessageEnvelopes，
      它是按消息触发的时间排序的。

      最后，我们来看下它的核心成员函数pollOnce，基本流程图如下所示 ：
      [[./images/2016/2016073001.jpg]]

      　　下面来分析上述过程：
      1. Handle response
         #+BEGIN_SRC c++
           for (;;) {
             while (mResponseIndex < mResponses.size()) {
               const Response& response = mResponses.itemAt(mResponseIndex++);
               int ident = response.request.ident;
               if (ident >= 0) {
                 int fd = response.request.fd;
                 int events = response.events;
                 void* data = response.request.data;
           #if DEBUG_POLL_AND_WAKE
                 ALOGD("%p ~ pollOnce - returning signalled identifier %d: "
                       "fd=%d, events=0x%x, data=%p",
                       this, ident, fd, events, data);
           #endif
                 if (outFd != NULL) *outFd = fd;
                 if (outEvents != NULL) *outEvents = events;
                 if (outData != NULL) *outData = data;
                 return ident;
               }
             }         
         #+END_SRC

         　　针对回调函数为空的情况，ident值必为一个大于等于0的值（注：
         有回调函数时，indent的值为-2）。所以上述这段代码只会发生在回
         调函数为空的情况，此时将返回发生事件的描述符，发生的事件以及
         返回的数据，供调用者进一步处理。

      2. Handle result.
         #+BEGIN_SRC c++
           for(;;) {
           ...
                  if (result != 0) {
           #if DEBUG_POLL_AND_WAKE
                       ALOGD("%p ~ pollOnce - returning result %d", this, result);
           #endif
                       if (outFd != NULL) *outFd = 0;
                       if (outEvents != NULL) *outEvents = 0;
                       if (outData != NULL) *outData = NULL;
                       return result;
                   }
           ...
           }         
         #+END_SRC

         这段代码实际上是根据pollInner的结果进行处理，实际上是针对设置
         了回调函数的情况，因为设置了回调函数，所以已经对发生的事件做
         了处理了，所以，不需要将发生事件的相关信息再返回给调用者了。

      3. pollInner
         #+BEGIN_SRC c++
           for(;;) {
           ...
            result = pollInner(timeoutMillis);
           }         
         #+END_SRC

         1. Ajust the time out.
            #+BEGIN_SRC c++
              int Looper::pollInner(int timeoutMillis) {
                  ...
                  // Adjust the timeout based on when the next message is due.
                  if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {
                      nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
                      int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
                      if (messageTimeoutMillis >= 0
                              && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {
                          timeoutMillis = messageTimeoutMillis;
                      }
              　　...
              　　}
              　　...
              }            
            #+END_SRC
            　　为什么要调整超时时间值，原因很简单：因为对于消息来说，
            可能有多个消息，且每个消息触发的时间点不同，一次事件的触发
            导致epoll_wait返回并不能处理完所有的消息，所有会多次调用
            epoll_wait函数，由于超时值是第一次调用时指定的，所以再次调
            用时，需要重新计算，要去掉已经消耗的时间。代码中now记录当
            前的时间值，toMillisecondTimeoutDelya(...)计算这本次循环的
            超时值。上述的判断条件指明了什么情况下需要做些调整：
            - 当前的消息触发时间不早于当前时间。（即消息没有过时）

            - 上轮 =epoll_wait= 指定的超时值为-1或一个较大的数值（>
              messageTimeoutMillis）。

         2. wait for event(epoll wait)
            #+BEGIN_SRC c++
                  ...
                  struct epoll_event eventItems[EPOLL_MAX_EVENTS];
              　　int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
              　　...            
            #+END_SRC

            主要通过 =epoll_wait= 系统调用检测事件的发生。

         3. handle the event

            #+BEGIN_SRC c++
              ...
                for (int i = 0; i < eventCount; i++) {
                      int fd = eventItems[i].data.fd;
                      uint32_t epollEvents = eventItems[i].events;
                      if (fd == mWakeReadPipeFd) {
                          if (epollEvents & EPOLLIN) {
                              awoken();
                          } else {
                              ALOGW("Ignoring unexpected epoll events 0x%x on wake read pipe.", epollEvents);
                          }
                      } else {
                          ssize_t requestIndex = mRequests.indexOfKey(fd);
                          if (requestIndex >= 0) {
                              int events = 0;
                              if (epollEvents & EPOLLIN) events |= ALOOPER_EVENT_INPUT;
                              if (epollEvents & EPOLLOUT) events |= ALOOPER_EVENT_OUTPUT;
                              if (epollEvents & EPOLLERR) events |= ALOOPER_EVENT_ERROR;
                              if (epollEvents & EPOLLHUP) events |= ALOOPER_EVENT_HANGUP;
                              pushResponse(events, mRequests.valueAt(requestIndex));
                          } else {
                              ALOGW("Ignoring unexpected epoll events 0x%x on fd %d that is "
                                      "no longer registered.", epollEvents, fd);
                          }
                      }
              　　}
              　　...            
            #+END_SRC

            　　对于Looper对象内置的管道，处理EPOLLIN事件，而对于其他
            监听的文件描述符，则分别记录下EPOLLIN， EPOLLOUT，
            EPOLLERR， EPOLLHUP并打包成Response对象加入到mResponses中
            进行处理。

         4. invoke pending message callbacks
            #+BEGIN_SRC c++
                // Invoke pending message callbacks.
                  mNextMessageUptime = LLONG_MAX;
                  while (mMessageEnvelopes.size() != 0) {
                      nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
                      const MessageEnvelope& messageEnvelope = mMessageEnvelopes.itemAt(0);
                      if (messageEnvelope.uptime <= now) {
                          // Remove the envelope from the list.
                          // We keep a strong reference to the handler until the call to handleMessage
                          // finishes.  Then we drop it so that the handler can be deleted *before*
                          // we reacquire our lock.
                          { // obtain handler
                              sp<MessageHandler> handler = messageEnvelope.handler;
                              Message message = messageEnvelope.message;
                              mMessageEnvelopes.removeAt(0);
                              mSendingMessage = true;
                              mLock.unlock();

              #if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                              ALOGD("%p ~ pollOnce - sending message: handler=%p, what=%d",
                                      this, handler.get(), message.what);
              #endif
                              handler->handleMessage(message);
                          } // release handler

                          mLock.lock();
                          mSendingMessage = false;
                          result = ALOOPER_POLL_CALLBACK;
                      } else {
                          // The last message left at the head of the queue determines the next wakeup time.
                          mNextMessageUptime = messageEnvelope.uptime;
                          break;
                      }
                  }            
            #+END_SRC

            messageEnvelope.uptime代表该消息被处理的时机，先处理掉已经
            过时的消息，即messageEnvelope.uptime <= now， 如果还有未过
            时的消息，则记录下它应该被处理的时间：mNextMessageUptime =
            messageEnvelope.uptime；也即下次被触发的时间。这个值也作为
            3.1中调整epoll_wait超时时间的值。

         5. invoke all response callback
            　　对于回调函数不为空的情形，在事件触发后，就会自动执行调
            用者提供的回调函数，如下面代码所示：

            #+BEGIN_SRC c++
               // Invoke all response callbacks.
                  for (size_t i = 0; i < mResponses.size(); i++) {
                      Response& response = mResponses.editItemAt(i);
                      if (response.request.ident == ALOOPER_POLL_CALLBACK) {
                          int fd = response.request.fd;
                          int events = response.events;
                          void* data = response.request.data;
              #if DEBUG_POLL_AND_WAKE || DEBUG_CALLBACKS
                          ALOGD("%p ~ pollOnce - invoking fd event callback %p: fd=%d, events=0x%x, data=%p",
                                  this, response.request.callback.get(), fd, events, data);
              #endif
                          int callbackResult = response.request.callback->handleEvent(fd, events, data);
                          if (callbackResult == 0) {
                              removeFd(fd);
                          }
                          // Clear the callback reference in the response structure promptly because we
                          // will not clear the response vector itself until the next poll.
                          response.request.callback.clear();
                          result = ALOOPER_POLL_CALLBACK;
                      }            
            #+END_SRC

   *三、Looper类应用实例分析*

   　　下面来看下Looper类的API的使用。
   1. Looper对象初始化
      #+BEGIN_SRC c++
        sp<Looper> mLooper = new Looper(true);
        ...
        mLooper.clear();      
      #+END_SRC
   2. pollOnece函数的使用
      #+BEGIN_SRC c++
        StopWatch stopWatch("pollOnce");
        int result = mLooper->pollOnce(1000);
        int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());      
      #+END_SRC
      返回值为 result = =ALOOPER_POLL_WAKE=
   3. 设置CallBack
      定义回调函数：
      #+BEGIN_SRC c++
        class CallbackHandler {
        public:
            void setCallback(const sp<Looper>& looper, int fd, int events) {
                looper->addFd(fd, 0, events, staticHandler, this);
            }

        protected:
            virtual ~CallbackHandler() { }

            virtual int handler(int fd, int events) = 0;

        private:
            static int staticHandler(int fd, int events, void* data) {
                return static_cast<CallbackHandler*>(data)->handler(fd, events);
            }
        };

        class StubCallbackHandler : public CallbackHandler {
        public:
            int nextResult;
            int callbackCount;

            int fd;
            int events;

            StubCallbackHandler(int nextResult) : nextResult(nextResult),
                    callbackCount(0), fd(-1), events(-1) {
            }

        protected:
            virtual int handler(int fd, int events) {
                callbackCount += 1;
                this->fd = fd;
                this->events = events;
                return nextResult;
            }
        };      
      #+END_SRC

      使用实例：
      #+BEGIN_SRC c++
        Pipe pipe;
        StubCallbackHandler handler(true);

        pipe.writeSignal();
        handler.setCallback(mLooper, pipe.receiveFd, ALOOPER_EVENT_INPUT);

        StopWatch stopWatch("pollOnce");
        int result = mLooper->pollOnce(100);
        int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());
        　　...      
      #+END_SRC

      result的值为 =ALOOPER_POLL_CALLBACK= 。
   4. Callback为空的情形
      　　若设置Callback为空，此时事件的标识符ident必须是一个大于或等
      于0的值。如下代码所示：
      #+BEGIN_SRC c++
        const int expectedIdent = 5;
        void* expectedData = this;

        Pipe pipe;

        pipe.writeSignal();
        mLooper->addFd(pipe.receiveFd, expectedIdent, ALOOPER_EVENT_INPUT, NULL, expectedData);

        StopWatch stopWatch("pollOnce");
        int fd;
        int events;
        void* data;
        int result = mLooper->pollOnce(100, &fd, &events, &data);
        int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());      
      #+END_SRC
      
      此时返回值result等于ident的值。
   5. 通过Looper发送消息
      　　此种情况下一般不需要调用addFd，通过Looper默认创建的管道来监
      听事件就行了。它的使用示例如下：
      　　首先要定义一个MessageHandler的派生类，用于处理消息：
      #+BEGIN_SRC c++
        class StubMessageHandler : public MessageHandler {
        public:
            Vector<Message> messages;

            virtual void handleMessage(const Message& message) {
                messages.push(message);
            }
        };      
      #+END_SRC

      接着就可以通过SendMessage相关的函数发送消息到Looper实例上：

      #+BEGIN_SRC c++
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        sp<StubMessageHandler> handler = new StubMessageHandler();
        mLooper->sendMessageAtTime(now + ms2ns(100), handler, Message(MSG_TEST1));

        StopWatch stopWatch("pollOnce");
        int result = mLooper->pollOnce(1000);
        int32_t elapsedMillis = ns2ms(stopWatch.elapsedTime());

        ...

        result = mLooper->pollOnce(1000);
        elapsedMillis = ns2ms(stopWatch.elapsedTime());

        ...
        result = mLooper->pollOnce(100);
        elapsedMillis = ns2ms(stopWatch.elapsedTime());

                  
      #+END_SRC

      #+BEGIN_EXAMPLE
        第一次
        elapsedMillis = 0;
        result = ALOOPER_POLL_WAKE
        Message size = 0;
        第二次
        elapsedMillis = 100
        result = ALOOPER_POLL_CALLBACK
        Message size = 1
        第三次
        result = ALOOPER_POLL_TIMEOUT
        没有消息需要处理。      
      #+END_EXAMPLE
