#+STARTUP: overview
#+STARTUP: hidestars
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="css/worg.css" type="text/css" />

* 内核模块
** 概述
   内核会为每个模块在如下路径下创建一个目录： =/sys/modules/=
** 模块参数
   #+BEGIN_SRC c
     module_param(multicast_filter_limit, int 0444);
     module_param(max_interrupt_work, int, 0444);
     module_param(debug, int, 0444);   
   #+END_SRC
* Userspace Helpers
  有时内核需要调用一个用户空间的程序运行。 
** =call_usermodehelper=
   内核函数 =request_module= 调用了上述方法。
* 通知链
  通知链存在的目的就是方便内核不同模块之间的消息传递， 仅限于内核子系
  统之间的通信。
  每个通知链包含 =passive side(the notified)= 和 =active side(the
  notifier)= ，即所谓的 =publish-and-subscribe= 模型。 
** 声明与定义
   1. =struct notifier_block= 
      #+BEGIN_SRC c
        struct notifier_block
        {
          int (*notifier_call)(struct notifier_block *self, unsigned long, void *);
          struct notifier_block *next;
          int priority;
        };      
      #+END_SRC
      其中 =nofifier_call= 是注册的回调函数。
** 注册
   | Operation | Function Prototype                                                                  |
   | 注册      | int notifier_chain_register(struct notifier_block **list, struct notifier_block*n)  |
   |           | Wrappers                                                                            |
   |           | inetaddr_chain register_inetaddr_notifier                                           |
   |           | inet6addr_chainregister_inet6addr_notifier                                          |
   |           | netdev_chain register_netdevice_notifier                                            |
   | 注销      | int notifier_chain_unregister(struct notifier_block **nl, struct notifier_block *n) |
   |           | Wrappers:                                                                           |
   |           | inetaddr_chain unregister_inetaddr_notifier                                         |
   |           | inet6addr_chainunregister_inet6addr_notifier                                        |
   |           | netdev_chain unregister_netdevice_notifier                                          |
   | 通知      | int notifier_call_chain(struct notifier_block **n, unsigned long val, void*v)       |

** 在通知链上产生消息
   通过调用 =notifier_call_chain= 来产生通知链。
   #+BEGIN_SRC c
     int notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)
     {
       int ret = NOTIFY_DONE;
       struct notifier_block *nb = *n;
       while (nb)
         {
           ret = nb->notifier_call(nb, val, v);
           if (ret & NOTIFY_STOP_MASK)
             {
               return ret;
             }
           nb = nb->next;
         }
       return ret;
     }   
   #+END_SRC

** 代码示例
   #+BEGIN_SRC c
     static struct notifier_block fib_inetaddr_notifier = {
       .notifier_call = fib_inetaddr_event,
     };
     static struct notifier_block fib_netdev_notifier = {
       .notifier_call = fib_netdev_event,
     };
     void _ _init ip_fib_init(void)
     {
       ... ... ...
       register_netdevice_notifier(&fib_netdev_notifier);
       register_inetaddr_notifier(&fib_inetaddr_notifier);
     }   
   #+END_SRC
* 内核线程
  =kthread_run=
  #+BEGIN_SRC c
    //内核任务描述
    typedef struct _OS_TASK_ {
      char task_name[256];
      void *priv;
      unsigned long task_status;
      struct task_struct *kthread_struct;
      wait_queue_head_t kthread_q;
      unsigned char kthread_running;
    } OS_TASK;
  #+END_SRC
* 文件操作
** 文件读写准备
   #+BEGIN_SRC c
     mm_segment_t orig_fs;

     orig_fs = get_fs();
     set_fs(KERNEL_DS);

     /* file read and write **/


     set_fs(orig_fs);
   #+END_SRC
** 打开文件
   #+BEGIN_SRC c
     struct file * open_file(char *path, int flag, int mode)
     {
       struct file *file_ptr = NULL;

       file_ptr = filp_open(path, flag, 0);
       if (IS_ERR(file_ptr)) {
         printk(KERN_WARNING "open file failed, reason: %s\n", PTR_ERR(file_ptr));
       }

       return file_ptr;
     }
   #+END_SRC
** 关闭文件
   #+BEGIN_SRC c
     int close_file(struct file* file)
     {
       filp_close(file, NULL);
       return 0;
     }
   #+END_SRC
** Seek文件
   #+BEGIN_SRC c
     void file_seek(struct file* file, int offset)\
     {
       file->f_pos = offset;
     }
   #+END_SRC
** read
   #+BEGIN_SRC c
     int file_read(struct file *file, char *buffer, int len)
     {
       if (file->f_op && file->f_op->read)
         return file->f_op->read(file, buffer, len, &file->f_pos);
       else {
         printk(KERN_WARNING "no file read method\n");
         return -1
       }

       return 0;
     }
   #+END_SRC
** write
   #+BEGIN_SRC c
     int file_write(struct file *file, char *buffer, int len)
     {
      
       if (file->f_op && file->f_op->write)
         return file->f_op->write(file, buffer, len, &file->f_pos);
       else {
         printk(KERN_WARNING "no file write method\n");
         return -1
       }

       return 0;
     }
   #+END_SRC
** blocking read and write
** polling
** mmap
** ioctl
* kfifo
* completion
* interrupt
* tasklet
* 时间与计时器
** 获取时间
   #+BEGIN_SRC c
     //1. 获取启动时间
     #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32))
     struct timespec ts;
     unsigned long long boot_time;
     //...
     get_monotonic_boottime(&ts);
     boot_time = ts.tv_sec;
     toot_time *= USEC_PER_SEC;
     boot_time += ts.tv_nsec/NSEC_PER_USEC;
     #else
     struct timeval tv;
     unsigned long long boot_time;
     //...
     do_gettimeofday(&tv);
     boot_time = ((unsigned long long)tv.tv_sec * 1000000) + tv.tv_usec;
     #endif

   #+END_SRC
* 工作队列
  #+BEGIN_SRC c
    struct work_struct * work_item;
    void (*pFunc)(unsigned long data);
    INIT_WORK(work_item, pFunc);
    schedule_work(...)
  #+END_SRC
* simple single misc device file (miscdevice, misc_register)
* platform_driver and platform_device in another module
* simple UART driver on port 0x3f8 with IRQ 4
* 文件系统
  #+BEGIN_SRC c
  flush_dcache_range(...)
  #+END_SRC
* 内核文件系统
** procfs
** sysctl
   #+BEGIN_SRC c
     ctl_table

     register_sysctl_table
     unregister_sysctl_table
   #+END_SRC
** sysfs
** debugfs
