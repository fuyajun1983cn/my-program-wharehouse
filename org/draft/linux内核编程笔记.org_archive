#    -*- mode: org -*-


Archived entries from file e:/cygwin/home/mtk71339/myplayground/org/draft/linux内核编程笔记.org


* 知识点37 platform设备驱动
  :PROPERTIES:
  :ARCHIVE_TIME: 2016-11-30 周三 19:25
  :ARCHIVE_FILE: ~/myplayground/org/draft/linux内核编程笔记.org
  :ARCHIVE_CATEGORY: linux内核编程笔记
  :END:
　　在Linux 2.6的设备驱动模型中，主要关心总线、设备和驱动这3个实体，总
   线将设备和驱动绑定。在系统每注册一个设备的时候，会寻找与之匹配的驱动；
   相反的，在系统每注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线
   完成。
   
　　一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附
   于PCI、USB、I2 C、SPI等的设备而言，这自然不是问题，但是在嵌入式系统里
   面，SoC系统中集成的独立的外设控制器、挂接在SoC内存空间的外设等却不依附
   于此类总线。基于这一背景，Linux发明了一种虚拟的总线，称为platform总线，
   相应的设备称为 =platform_device= ，而驱动成为 =platform_driver= 。
   
　　注意，所谓的 =platform_device= 并不是与字符设备、块设备和网络设备并列的
   概念，而是Linux系统提供的一种附加手段，例如，在S3C6410处理器中，把内部
   集成的I2 C、RTC、SPI、LCD、看门狗等控制器都归纳为 =platform_device= ，而它
   们本身就是字符设备。
   
   =platform_device= 结构体的定义如代码所示：
   [[./images/2016/2016071605.png]]
  
   =platform_driver=  这个结构体中包含probe()、remove()、shutdown()、
   suspend()、resume()函数，通常也需要由驱动实现， 如下代码所示：
    [[./images/2016/2016071606.png]]
   
　　系统中为platform总线定义了一个 =bus_type= 的实例 =platform_bus_type=
    ，其定义如代码所示：

     [[./images/2016/2016071607.png]]

     这里要重点关注其match()成员函数，正是此成员表明了 =platform_device= 和
     =platform_driver= 之间如何匹配，如代码所示：
     
     [[./images/2016/2016071608.png]]
     
     　　匹配 =platform_device= 和 =platform_driver= 会采取多种方式，其中名字匹配是一
     种匹配方式。
     
     　　对 =platform_device= 的定义通常在BSP的板文件中实现，在板文件中，将
     =platform_device= 归纳为一个数组，最终通过 =platform_add_devices()= 函数统一注
     册。 =platform_add_devices()= 函数可以将平台设备添加到系统中，这个函数的原型
     为：
     : int platform_add_devices(struct platform_device **devs, int num);
     
     　　该函数的第一个参数为平台设备数组的指针，第二个参数为平台设备的数量，
     它内部调用了 =platform_device_register()= 函数用于注册单个的平台设备。
     
     =platform_device= 的资源由resource结构体描述，其定义如代码所示：
     
     [[./images/2016/2016071609.png]]

     我们通常关心start、end和flags这3个字段，分别标明资源的开始值、结束值和
     类型，flags可以为 =IORESOURCE_IO= 、 =IORESOURCE_MEM= 、
     =IORESOURCE_IRQ= , =IORESOURCE_DMA= 等。start、end的含义会随着flags而变更，如当 flags为
     =IORESOURCE_MEM= 时，start、end分别表示该 =platform_device= 占据的内存的开始地
     址和结束地址；当 flags为 =IORESOURCE_IRQ= 时，start、end分别表示该
     =platform_device= 使用的中断号的开始值和结束值，如果只使用了 1个中断号，开
     始和结束值相同。对于同种类型的资源而言，可以有多份，譬如说某设备占据了
     2个内存区域，则可以定义2个 =IORESOURCE_MEM= 资源。
     
     　　对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中透
     过 =platform_get_resource()= 这样的API来获取，此API的原型为：
     : struct resource *platform_get_resource(struct platform_device *, unsigned int, unsigned int);
     
     设备除了可以在BSP中定义资源以外，还可以附加一些数据信息，因为对设备的
     硬件描述除了中断、内存、DMA通道以外，可能还会有一些配置信息，而这些配
     置信息也依赖于板，不适宜直接放置在设备驱动本身，因此，platform也提供了
     =platform_data= 的支持。 =platform_data= 的形式是自定义的。
     [[./images/2016/2016071610.png]]

     　　可以看到 =platform_data= 是一个void型的指针，可以指向任何自定义的数据结
     构，我们可以将MAC地址、总线宽度、有无EEPROM信息放入 =platform_data= 。通过
     =platform_device_add_data= 可以向给 =platform_data= 赋值，其代码如下：
     [[./images/2016/2016071611.png]]
     
     由以上分析可知，设备驱动中引入platform的概念至少有如下2大好处：
     1. 使得设备被挂接在一个总线上，因此，符合Linux 2.6的设备模型。其结果是，
         配套的sysfs结点、设备电源管理都成为可能。
     2. 隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体
         配置信息，而在驱动中，只需要通过通用API去获取资源和数据，做到了板相
        关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。


     在较新的内核中，提供了宏 =module_platform_driver= 来注册一个
     =platform_driver= :
     #+BEGIN_SRC c
       static struct platform_driver xxx_driver = {
               .driver = {
                       .name = "xxx",
                       .of_match_table = xxx_match,
                       .pm = SDHCI_PLTFM_PMOPS,
               },
               .probe = xxx_probe,
               .remove = xxx_remove,
       };
       module_platform_driver(xxx_driver);     
     #+END_SRC

     *后记：*

     内核有时需要被告知平台上硬件实际呈现的方式，这时，“平台设备”这
     个概念就有用武之道。

     "平台设备"会被连接到一个虚拟的“平台总线”上，为此，平台设备需要
     注册到此平台总线上。将平台设备与对应的驱动绑定是通过总线代码实现
     的。有两种机制来实现这种目的，第一种是通过 =id_table= 参数，相关
     的数据结构如下：
     #+BEGIN_SRC c
       struct platform_device_id {
         char name[PLATFORM_NAME_SIZE];
         kernel_ulong_t driver_data;
       };     
     #+END_SRC

     如果ID表存在的话，平台总线代码每次在为一个新的设备寻找驱动时，会
     扫描它。如果ID表中的名字与设备的名字匹配，则该设备就会交给相应的
     驱动去管理，同时指向该ID表的指针也会传递给驱动去访问。

     但实际上，许多驱动程序并没有提供这样的一个ID表，它仅仅在驱动中提
     供一个名字，如下所示：
     #+BEGIN_SRC c
       static struct platform_driver i2c_gpio_driver = {
               .driver         = {
                       .name   = "i2c-gpio",
                       .owner  = THIS_MODULE,
               },
               .probe          = i2c_gpio_probe,
               .remove         = __devexit_p(i2c_gpio_remove),
           };     
     #+END_SRC

     根据上述配置，任何标识为"i2c-gpio"的设备都会被绑定到此驱动中。不
     需要任何ID表。

     驱动通过如下函数注册到内核中：
     : int platform_driver_register(struct platform_driver *driver);

     当运行了上述函数后，一旦检测到新的设备，则会立即运行probe()函数，
     该函数有一个 =platform_device= 的指针，描述了即将被初始化的设备。
     #+BEGIN_SRC c
       struct platform_device {
               const char      *name;
               int             id;
               struct device   dev;
               u32             num_resources;
               struct resource *resource;
               const struct platform_device_id *id_entry;
               /* Others omitted */
           };     
     #+END_SRC
     =dev= 可被用于各种上下文中，如果使用的是ID表的方式匹配设备的话，
     则 =id_entry= 会指向特定的匹配表项。 =resource=  可以用于了解当前
     各种资源的访问信息，包含内存映射I/O寄存器访问地址，中断线等。有如
     下 一些函数接口可用：
     #+BEGIN_SRC c
       struct resource *platform_get_resource(struct platform_device *pdev, 
                                              unsigned int type, unsigned int n);
       struct resource *platform_get_resource_byname(struct platform_device *pdev,
                                                     unsigned int type, const char *name);
       int platform_get_irq(struct platform_device *pdev, unsigned int n);     
     #+END_SRC
     如果probe()函数找到所需的信息，它会验证设备是否真实存在，并注册实
     际的设备与“平台设备”关联，并返回0. 
     
     通过上述的接口，我们注册了平台设备驱动，但是并没有实际的设备存在。
     由于平台设备是不能被自动发现的，所以必须有一种其他的方式来告知内
     核设备的存在。通常是通过创建一个静态的 =platform_device= 数据结构
     实例，如下所示：
     #+BEGIN_SRC c
       static struct resource foomatic_resources[] = {
               {
                       .start  = 0x10000000,
                       .end    = 0x10001000,
                       .flags  = IORESOURCE_MEM,
                       .name   = "io-memory"
               },
               {
                       .start  = 20,
                       .end    = 20,
                       .flags  = IORESOURCE_IRQ,
                       .name   = "irq",
               }
           };

           static struct platform_device my_foomatic = {
               .name           = "foomatic",
               .resource       = foomatic_resources,
               .num_resources  = ARRAY_SIZE(foomatic_resources),
           };     
     #+END_SRC

     通过调用如下函数来告诉内核设备的存在：
     : int platform_device_register(struct platform_device *pdev);

     NOTES:for lots of use cases it's better not to register static
     instance of platform device, but rather allocate it dynamically,
     via =platform_device_register_{simple,data,resndata}()= functions
     or via =platform_device_alloc()/platform_device_add()=.


     一旦当设备与驱动都注册到内核后，驱动对应的probe()函数就会被调用，
     且设备也可以被初始化。 设备的注册和驱动的注册通常发生在不同的地方，
     注册的先后顺序则不重要。

     对于简单的平台设备，上述信息就足够了。但是，对于 一些比较复杂的平
     台设备，需要传递额外的信息，这种额外的信息是通过"platform data"来
     传递的，它通过 =dev.platform_data= 来传递，如下所示：
     #+BEGIN_SRC c
       static struct i2c_gpio_platform_data my_i2c_plat_data = {
               .scl_pin        = 100,
               .sda_pin        = 101,
           };

           static struct platform_device my_gpio_i2c = {
               .name           = "i2c-gpio",
               .id             = 0,
               .dev = {
                       .platform_data = &my_i2c_plat_data,
               }
           };     
     #+END_SRC
     
     在驱动 的probe()函数中，可以获取 =platform_data= 的指针，并通过它
     来获取余下所需所需的信息。
     
