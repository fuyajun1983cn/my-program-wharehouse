#+STARTUP: overview
#+STARTUP: hidestars
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="css/worg.css" type="text/css" />

* =wpa_supplicant= 基本架构分析[fn:1] [fn:2]
** 模块结构图
     #+CAPTION:  =wpa_supplicant modules=
     [[./images/2015/2015121506.png]]
** 全局数据结构  
*** =struct wpa_supplicant= 
*** =struct wpa_global=
*** =struct wpa_radio=
    #+BEGIN_SRC c
      /**
       ,* struct wpa_radio - Internal data for per-radio information
       ,*
       ,* This structure is used to share data about configured interfaces
       ,* (struct wpa_supplicant) that share the same physical radio, e.g., to allow
       ,* better coordination of offchannel operations.
       ,*/
      struct wpa_radio {
              char name[16]; /* from driver_ops get_radio_name() or empty if not
                              ,* available */
              unsigned int external_scan_running:1;
              unsigned int num_active_works;
              struct dl_list ifaces; /* struct wpa_supplicant::radio_list entries */
              struct dl_list work; /* struct wpa_radio_work::list entries */
      };
          
    #+END_SRC
*** =struct wpa_radio_work= 
    Radio work item, 数据结构定义如下：
    #+BEGIN_SRC c
      /**
       ,* struct wpa_radio_work - Radio work item
       ,*/
      struct wpa_radio_work {
              struct dl_list list;
              unsigned int freq; /* known frequency (MHz) or 0 for multiple/unknown */
              const char *type;
              struct wpa_supplicant *wpa_s;
              void (*cb)(struct wpa_radio_work *work, int deinit);
              void *ctx;  //pointer to struct wpa_connect_work  ==>Yajun
              unsigned int started:1;
              struct os_reltime time;
              unsigned int bands;
      };
    #+END_SRC
    相关的函数接口
    1. =radio_add_work=
    2. =radio_work_done=
    3. =radio_remove_works=
    4. =radio_work_check_next=
    5. =radio_work_pending=
*** =struct nl80211_global=
    #+BEGIN_SRC c
      struct nl80211_global {
              struct dl_list interfaces;
              int if_add_ifindex;
              u64 if_add_wdevid;
              int if_add_wdevid_set;
              struct netlink_data *netlink;
              struct nl_cb *nl_cb;
              struct nl_handle *nl;
              int nl80211_id;   //family id for nl802.11
              int ioctl_sock; /* socket for ioctl() use */

              struct nl_handle *nl_event;
      };    
    #+END_SRC
    其中 =nl_event= 接收Driver上报的事件。
    =nl= 用于 =wpa_supplicant= 向Driver下一些 netlink 命令。
*** =struct wpa_driver_nl80211_data= 
*** =struct i802_bss=
    #+BEGIN_SRC c
      struct i802_bss {
              struct wpa_driver_nl80211_data *drv;
              struct i802_bss *next;
              int ifindex;
              u64 wdev_id;
              char ifname[IFNAMSIZ + 1];
              char brname[IFNAMSIZ];
              unsigned int beacon_set:1;
              unsigned int added_if_into_bridge:1;
              unsigned int added_bridge:1;
              unsigned int in_deinit:1;
              unsigned int wdev_id_set:1;

              u8 addr[ETH_ALEN];

              int freq;
              int if_dynamic;

              void *ctx;
              struct nl_handle *nl_preq, *nl_mgmt;
              struct nl_cb *nl_cb;

              struct nl80211_wiphy_data *wiphy_data;
              struct dl_list wiphy_list;
      };    
    #+END_SRC
    =struct nl_mgmt= 注册管理帧，如Action帧. 在设置设备模式
    =wpa_driver_nl80211_set_mode= 的时候，
    =wpa_supplicant= 会向Driver注册一些Action帧。
*** =struct nl80211_global=
    #+BEGIN_SRC c
      struct nl80211_global {
              struct dl_list interfaces;
              int if_add_ifindex;
              u64 if_add_wdevid;
              int if_add_wdevid_set;
              struct netlink_data *netlink;
              struct nl_cb *nl_cb;
              struct nl_handle *nl;
              int nl80211_id;
              int ioctl_sock; /* socket for ioctl() use */

        //netlink socket
        //接收Driver回报的一些事件(广播事件)，如scan, mlme, regulatory,vendor
              struct nl_handle *nl_event;
      };    
    #+END_SRC
** =wpa_supplicant= 初始化分析
*** =wpa_supplicant= 初始化执行过程

     #+BEGIN_SRC plantuml :file ./images/2015/2015123004.png :cmdline -charset UTF-8
       title wpa_supplicant初始化流程
       @startuml
       start
       :os_program_init;
       :wpa_supplicant_fd_workaround(1);
       :解析传递进来的一些参数;
       #Blue:wpa_supplicant_init;
       note right: 初始化""struct wpa_global""实例
       #Blue:wpa_supplicant_add_iface;
       note right: 添加一个或多个网络接口, 并完成大部分初始化工作。
       if (CONFIG_P2P) then (yes)
       #Blue:wpas_p2p_add_p2pdev_interface;
       note right: 添加P2P设备接口
       endif
       #Blue:wpa_supplicant_run;
       note right: 运行eloop事件循环
       :wpa_supplicant_fd_workaround(0);
       :os_program_deinit;
       stop
       @enduml
     #+END_SRC

     #+RESULTS:
     [[file:./images/2015/2015123004.png]]

*** =wpa_supplicant_init= 函数执行过程

    #+BEGIN_SRC plantuml :file ./images/2016/2016011410.png :cmdline -charset UTF-8
      title wpa_supplicant_init函数执行过程
      start
      :wpa_debug_open_file;
      if (params->wpa_debug_tracing==1) then (yes)
      :wpa_debug_open_linux_tracing;
      endif
      :eap_register_methods();
      note right: 注册EAP方法
      :保存传进来的参数;
      :eloop_init;
      :random_init;
      :wpa_supplicant_global_ctrl_iface_init;
      note right: 初始化全局控制接口
      :wpas_notify_supplicant_initialized;
      note right: 发布初始化完成通知
      if (wifi display enabled) then (yes)
      :wifi_display_init;
      note right: 初始化Wifi Display
      endif
      end
    #+END_SRC

    #+RESULTS:
    [[file:./images/2016/2016011410.png]]

    接下来看 =wpa_supplicant_global_ctrl_iface_init= 的执行过程。
    
     #+BEGIN_SRC plantuml :file ./images/2015/2015123002.png :cmdline -charset UTF-8
       title: wpa_supplicant_global_ctrl_iface_init执行过程
       :wpa_supplicant_init;
       note right: global->ctrl_iface = wpa_supplicant_global_ctrl_iface_init(global)
       :wpa_supplicant_global_ctrl_iface_init;
       note right
       注册一个socket的读事件处理(ctrl_iface_unix.c)
       ====
       eloop_register_read_sock(priv->sock,
                                wpa_supplicant_global_ctrl_iface_receive,
                                global, priv)                    
       end note
       :wpa_supplicant_global_ctrl_iface_receive;
       note left : Global ctrl_iface (ctrl_iface_unix.c)
       :wpa_supplicant_global_ctrl_iface_process;
       if (不是P2P或WFD) then (yes)
       :wpas_global_ctrl_iface_ifname;
       else (no)
       :wpas_global_ctrl_iface_redir;
       if (P2P) then (yes)
       :wpas_global_ctrl_iface_redir_p2p;
       note left: 处理p2p命令
       else (no)
       :wpas_global_ctrl_iface_redir_wfd;
        note right: 处理WFD命令
       endif
       endif 
       :wpa_supplicant_ctrl_iface_process;
       note right: 处理其他类型的命令
     #+END_SRC 

     #+RESULTS:
     [[file:./images/2015/2015123002.png]]

*** =wpa_supplicant_add_iface= 函数执行过程 
     
     #+BEGIN_SRC plantuml :file ./images/2015/2015123003.png :cmdline -charset UTF-8
       title: 添加一个新的网络接口, 返回一个 wpa_supplicant 结构的数据对象
       : wpa_supplicant_add_iface;
       note right
        添加一个新的网络接口(wpa_supplicant.c)
        可以在""wpa_supplicant_run()""之前调用，也可以
        在之后调用(即eloop运行起来后)
        end note
       #Blue:wpa_supplicant_init_iface;
       note right: 初始化一个网络接口(wpa_supplicant.c)
       :wpa_supplicant_ctrl_iface_init;
       note right
       注册一个socket读事件处理
       ====
       eloop_register_read_sock(priv->sock, wpa_supplicant_ctrl_iface_receive,
                                        wpa_s, priv);
       end note
       :wpa_supplicant_ctrl_iface_receive;
       :wpa_supplicant_ctrl_iface_process;
     #+END_SRC

     #+RESULTS:
     [[file:./images/2015/2015123003.png]]

**** =wpa_supplicant_init_iface= 

        初始化网络接口， 读取配置文件，初始化EAPOL状态机，初始化Driver，
        初始化 wpa状态机等等。

        #+BEGIN_SRC plantuml :file ./images/2016/2016010501.png :cmdline -charset UTF-8
          title wpa_supplicant_init_iface初始化代码分析
          
          @startuml
          start
          :wpa_config_read;
          note right: 读取配置文件的参数，并配置相应参数。
          : eapol_sm_notify_portEnabled() \n eapol_sm_notify_portValid();
          note right: 初始化RSNA Supplicant Key Management
          : wpa_supplicant_set_driver;
          note right: 设置驱动
          : wpa_drv_init\nwpa_drv_set_param;
          note right: 初始化驱动, 设置驱动参数
          #Red: wpa_supplicant_init_wpa;
          note right: 初始化wpa状态机
          :wpa_sm_set_param;
          note right: wpa状态机相关参数的设定
          :wpa_drv_get_capa;
          note right: 查询驱动的能力信息
          #Blue: wpa_supplicant_driver_init;
          note right: 初始化驱动接口参数
          :wpa_tdls_init;
          note right: 设置TDLS驱动接口参数
          :wpa_drv_set_country;
          note right: 设置国家码
          #Green: wpas_wps_init;
          note right: 初始化WPS
          #Red: wpa_supplicant_init_eapol;
          note right: EAPOL状态机初始化
          :wpa_sm_set_eapol;
          note right: 设置WPA状态机的EAPOL state machine pointer
          #Blue: wpa_supplicant_ctrl_iface_init;
          note right: 初始化控制接口
          :gas_query_init;
          note right: 初始化gas
          if (iface->p2p_mgmt) then (yes)
          #Green: wpas_p2p_init;
          note right: 初始化p2p模块
          endif
          :wpa_bss_init;
          note right: 初始化BSS表
          if (CONFIG_EAP_PROXY) then (yes)
          :eap_proxy_get_imsi;
          endif
          :pcsc_reader_init;
          :wpas_init_ext_pw;
          stop
          @enduml
        #+END_SRC

        #+RESULTS:
        [[file:./images/2016/2016010501.png]]

** event loop
*** eloop data structure

         定义了事件循环接口，支持处理注册的超时事件（例如：过多少秒后，
         执行某个操作）， socket事件以及信号事件等。

**** eloop相关数据结构的关系
        #+CAPTION: struct eloop_data
        [[./images/2015/2015122901.png]]

        socket主要有读、写和异常等三种。 =struct eloop_sock_table= 是
        一个表结构，维护了当前所有的socket，针对读、写和异常分别对应一个
        表结构。
**** =eloop_sock=
***** eloop sock event type

            =eloop_register_sock()= 注册的socket事件类型。 

            #+BEGIN_SRC c
              typedef enum {
                      EVENT_TYPE_READ = 0,
                      EVENT_TYPE_WRITE,
                      EVENT_TYPE_EXCEPTION
              } eloop_event_type;
            #+END_SRC

            =event_sock= 主要的关注的事件是读、写和异常。
            
***** eloop socket event callback type

            #+BEGIN_SRC c
              /**
               ,* eloop_sock_handler - eloop socket event callback type
               ,*/
              typedef void (*eloop_sock_handler)(int sock, void *eloop_ctx, void *sock_ctx);
            #+END_SRC

**** eloop event
         通用事件
         
***** 回调函数
          #+BEGIN_SRC c
             /**
              ,,* eloop_event_handler - eloop generic event callback type
              ,,*/
             typedef void (*eloop_event_handler)(void *eloop_data, void *user_ctx);
          #+END_SRC

**** eloop timeout
        处理超时事件 
        
***** 回调函数
         #+BEGIN_SRC c
            /**
             ,,* eloop_timeout_handler - eloop timeout event callback type
             ,,*/
            typedef void (*eloop_timeout_handler)(void *eloop_data, void *user_ctx);
         #+END_SRC

**** eloop signal
        系统信号处理

***** 回调函数
          #+BEGIN_SRC c
             /**
              ,,* eloop_signal_handler - eloop signal event callback type
              ,,*/
             typedef void (*eloop_signal_handler)(int sig, void *signal_ctx);
          #+END_SRC
*** =eloop_init()=

          初始化一个全局的event loop data。 在其他 =eloop_*= 前调用。

*** 注册事件处理函数

          1. register socket读、写，异常等事件

             #+BEGIN_SRC c
               /*
                ,* Register a read socket notifier for the given file descriptor.
                ,*/
               int eloop_register_read_sock(int sock, eloop_sock_handler handler,
                                            void *eloop_data, void *user_data);
               /*
                ,*  Register an event notifier for the given socket's file descriptor.
                ,*/
               int eloop_register_sock(int sock, eloop_event_type type,
                                       eloop_sock_handler handler,
                                       void *eloop_data, void *user_data);
             #+END_SRC

          2. 注册系统相关事件

             #+BEGIN_SRC c
               int eloop_register_event(void *event, size_t event_size,
                                        eloop_event_handler handler,
                                        void *eloop_data, void *user_data);
             #+END_SRC

          3. 注册超时处理函数

             该函数将会在secs秒后执行。 
             #+BEGIN_SRC c
               int eloop_register_timeout(unsigned int secs, unsigned int usecs,
                                          eloop_timeout_handler handler,
                                          void *eloop_data, void *user_data);              
             #+END_SRC

          4. 注册信号处理函数

             #+BEGIN_SRC c
               int eloop_register_signal(int sig, eloop_signal_handler handler,
                                         void *user_data);

               /*
                ,*  registers handlers for SIGINT and SIGTERM.
                ,*/
               int eloop_register_signal_terminate(eloop_signal_handler handler,
                                                   void *user_data);
             #+END_SRC

*** start event loop
    
       #+BEGIN_SRC plantuml :file ./images/2015/2015123001.png :cmdline -charset UTF-8 
         @startuml
         start
         :eloop_init;
           note left: 该函数必须在其他的eloop_*函数之前调用
           while (当eloop循环没有停止且\n(当前timeout链表不为空\n或当前监控的读、写和异常事件的socket数量大于0))
           : get an entry from timeout list;
          if (timeout列表不为空) then (yes)
           if (预设的超时值与当前时间的差值不为0) then (yes)
           : 更新超时值;
           else (no)
           : 将当前超时值置为0;
           endif
          else (no)
          endif
           :设置当前监听的已打开的文件的句柄（读，写，异常);
           :通过select函数来捕获事件;
           :检查是否有信号事件需要处理;
           :检测是否有一些注册的timeout事件需要处理;
           if (有timeout事件要处理且设\n置的处理时间已经到期) then(yes)
           :调用timeout回调处理函数;
           :将当前已经处理的timeout回调函数从当前timeout列表中移除;
           else (no)
           endif
           :检查并处理发生的读、写和异常事件对应的处理函数。;
           endwhile
           end
           @enduml

       #+END_SRC

       #+RESULTS:
       [[file:./images/2015/2015123001.png]]

*** 其他一些 =eloop_*= 函数速速览
       #+BEGIN_SRC c
         /*
          ,* 监听发生在某个socket的读事件
          ,*/
         void eloop_wait_for_read_sock(int sock)

         /*
          ,* 注册一个系统信号处理函数
          ,*/
         int eloop_register_signal(int sig, eloop_signal_handler handler,
                                   void *user_data)

         /*
          ,* 处理目前已经触发的系统信号
          ,*/
         static void eloop_process_pending_signals(void)

         /*
          ,* 处理某个触发的系统信号
          ,*/
         static void eloop_handle_signal(int sig)

         /*
          ,* 检查一个timeout处理函数是否已经注册
          ,*/
         int eloop_is_timeout_registered(eloop_timeout_handler handler,
                                         void *eloop_data, void *user_data)

         /*
          ,*取消一个已经注册的timeout处理函数
          ,*/
         int eloop_cancel_timeout_one(eloop_timeout_handler handler,
                                      void *eloop_data, void *user_data,
                                      struct os_time *remaining)

         /*
          ,* 取消一个或多个已经注册的timeout处理函数
          ,*/
         int eloop_cancel_timeout(eloop_timeout_handler handler,
                                  void *eloop_data, void *user_data)

         /*
          ,* 从timeout链表中删除一个eloop_timeout项
          ,*/
         static void eloop_remove_timeout(struct eloop_timeout *timeout)

         /*
          ,* 注册一个eloop_timeout项，按超时时间的大小，从小
          ,* 到大的顺序排列
          ,*/
         int eloop_register_timeout(unsigned int secs, unsigned int usecs,
                                    eloop_timeout_handler handler,
                                    void *eloop_data, void *user_data)
         /*
          ,* 注册一个Socket监听对象，添加到相应的监控表中
          ,* (read, write, exception)
          ,*/
         int eloop_register_sock(int sock, eloop_event_type type,
                                 eloop_sock_handler handler,
                                 void *eloop_data, void *user_data)

         /*
          ,* 注册一个Socket监听对象，监测它的读事件
          ,*/
         int eloop_register_read_sock(int sock, eloop_sock_handler handler,
                                      void *eloop_data, void *user_data)


       #+END_SRC
** ctrl interface
*** 概述
    =wpa_supplicnat= 提供了控制接口，可以允许通过外部程序获得
    =wpa_supplicant= 的状态信息，并对其进行管理。相应文件说明如下：
    - =ctrl_iface.c and ctrl_iface.h=  =wpa_supplicant-side= of the
      control interface
    - =ctrl_iface_unix.c= UNIX domain =sockets-based= control interface
      backend
    - =ctrl_iface_udp.c= UDP =sockets-based= control interface backend
    - =ctrl_iface_named_pipe.c= Windows =named pipes-based= control
      interface backend
    - =wpa_ctrl.c and wpa_ctrl.h= Library functions for external
      programs to provide access to the wpa_supplicant control
      interface
    外部程序可以通过 =ctrl_iface= 向 =wpa_supplicant= 主动发送命令，也
    可以被动接收 =wpa_supplicant= 主动发送过来的一些事件报告。 在
    =wpa_supplicant_ctrl_iface_init= 中调用了 =wpa_msg_register_cb= 注册了
    callback函数 =wpa_supplicant_ctrl_iface_msg_cb= ， 在该函数中，会主动
    将supplicant中发生的一些关键事件发送给上层监听的对端，以便他们能够
    了解 =wpa_supplicant= 的状态变化 。在 =wpa_msg= , =wpa_msg_ctrl= ,
    =wpa_msg_global= , =wpa_msg_no_global= , 中会自动调用该回调函数 。
*** 主要API
     主要有两种类型的通信： 命令与底层主动发送的事件消息。
     命令由请求和响应组成。 如果要监听底层主动发上来的消息，必须注册监
     听器。
     1. 打开与 =wpa_supplicant= 的一个连接   
        #+BEGIN_SRC c
          struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path);
        #+END_SRC

     2. 发送命令
        #+BEGIN_SRC c
          int wpa_ctrl_request(struct wpa_ctrl *ctrl, const char *cmd,
                               size_t cmd_len, char *reply, size_t *reply_len,
                               void (*msg_cb)(char *msg, size_t len));
        #+END_SRC

     3. 注册控制接口的事件监听器  
        #+BEGIN_SRC c
          int wpa_ctrl_attach(struct wpa_ctrl *ctrl);
        #+END_SRC

     4. 接收来看控制接口的消息  
        #+BEGIN_SRC c
          int wpa_ctrl_recv(struct wpa_ctrl *ctrl, char *reply, size_t *reply_len);        
        #+END_SRC

     5. 检查是否有未决的事件消息  
        #+BEGIN_SRC c
          int wpa_ctrl_pending(struct wpa_ctrl *ctrl);        
        #+END_SRC
*** CMMAND
     - PING
     - MIB
     - STATUS
     - =STATUS-verbose=
     - PMKSA
     - SET <variable> <valus>
     - LOGON
     - LOGOFF
     - REASSOCIATE
     - RECONNECT
     - PREAUTH <BSSID>
     - ATTACH
     - DETACH
     - LEVEL <debug level>
     - RECONFIGURE
     - TERMINATE
     - BSSID <network id> <BSSID>
     - =LIST_NETWORKS=
     - DISCONNECT
     - SCAN
       SCAN流程分析
       wpa_supplicant_event --> EVENT_SCAN_RESULTS -->
       wpa_supplicant_event_scan_results
       每次扫描结束会，会调用 =wpas_select_network_from_last_scan= 来
       选择一个网络进行连接。
     - =SCAN_RESULTS=
     - BSS
     - =SELECT_NETWORK= <network id>
     - =ENABLE_NETWORK= <network id>
     - =DISABLE_NETWORK= <network id>
     - =ADD_NETWORK=
     - =REMOVE_NETWORK= <network id>
     - =SET_NETWORK= <network id> <variable> <value>
     - =GET_NETWORK= <network id> <variable>
     - =SAVE_CONFIG=

** configuration

   主要数据结构：
   #+BEGIN_SRC c
     struct wpa_config{
       
     };
   #+END_SRC
   函数 =wpa_config_alloc_empty(...)= 定义了所有成员的默认值，一些重要配置
   项如下所示：
   - =update_config= 
     是否允许 =wpa_supplicant= 覆盖(更新)配置文件（当配置文件发生变化时）。
   - =ctrl_interface= 
     这是一个全局配置，指定了该参数后， =wpa_supplicant= 会打开一个控
     制接口，外部程序可以通过此控制接口来管理 =wpa_supplicant= 。 字符
     串的含义取决于使用的控制接口的机制。 但是，有一点，只要配置了该参
     数，就表明启用了控制接口机制。 
     对于 =UNIX domain sockets= ， 这是为 =Unix domain socket= 创建的
     一个目录，用于监听来自外部程序的请求。 新创建的socket文件会在这个
     目录中，如对于接口名称为 =wlan0= 的接口，会在 =ctrl_interface= 指
     定的目录下创建一个socket文件： =wlan0= 。 
     通过修改 =wpa_ctrl= 指定的目录的权限来控制访问 =wpa_supplicant=
     ， 默认情况下， =wpa_supplicant= 默认配置为使用GID为0， 即root权
     限。 例如：
     #+BEGIN_SRC sh
     # DIR=/var/run/wpa_supplicant GROUP=wheel
     # DIR=/var/run/wpa_supplicant GROUP=0
     # (group can be either group name or gid)
     #+END_SRC

     对于 UDP连接（Windows默认行为），该值会被忽略。 该值只是用来选择
     将被创建的控制接口，该值可被设置为 =udp= 。( =control_interface=
     udp) 

     对于Windows的命名管道，该值用于设置访问控制接口的安全描述符。如
     #+BEGIN_EXAMPLE
      ctrl_interface=SDDL=D:= 。 
     #+END_EXAMPLE
   - =eapol_version= 
     设置 =IEEE 802.1X/EAPOL= 的版本， =wpa_supplicant= 是基于 =IEEE
     802.1X-2004 EAPOL version 2=  实现的，  但是为了兼容不支持
     version 2的AP，该值默认为设置为1. 当使用MACSec时，该值应该设置
     为3，在 =IEEE Std 802.1X-2010= 中有定义。
   - =ap_scan= 
     默认情况下， =wpa_supplicant= 会请求驱动执行AP扫描，然后使用扫描
     结果来选择一个合适的AP。另一种选择就是驱动负责AP扫描并选择一个AP
     来关联， =wpa_supplicant= 只是基于驱动给出的关联信息去处理 EAPOL
     帧。 有如下一些取值：  

     1: =wpa_supplicant= initiates scanning and AP selection; if no APs
     matching to  the currently enabled networks are found, a new
     network (IBSS or AP mode  operation) may be initialized (if
     configured) (default)

     0: driver takes care of scanning, AP selection, and IEEE 802.11
     association parameters; 
      
     2: like 0, but associate with APs using security policy and SSID
     (but not BSSID);在这种模式下，驱动会一个一个地尝试关联配置文件中
     指定的网络，直到关联成功。另外，每个网络必须显式地配置安全策略。

     对于使用 =nl80211= 驱动接口，一般选择 =ap_scan=1= ， 在这种模式
     下，会先逐一扫描配置文件中的网络，如果没有合适的网络，会创建一个IBSS或
     AP模式下的网络 。当使用IBSS或AP模式，使用 =ap_scan=2= 可以强制立
     即创建新的网络，而不管扫描结果为何。
   - =passive_scan= 
     是否强制被动扫描。

     0:  Do normal scans (allow active scans) (default)

     1:  Do passive scans.

     如果开启被动扫描，则会降低扫描设备的速度，且会导致有些AP扫不到，
     如隐藏SSID的AP。
   - =user_mpm= 
     默认情况下， =wpa_supplicnat= 会为一个Open Mesh实现MPM(Mesh
     Peering Manager)，如果驱动实现了MPM，可以设置些值为0. 
     
     0: MPM lives in the driver

     1: wpa_supplicant provides an MPM which handles peering (default)
   - =max_peer_links= 
     Maximum number of mesh peering currently maintained by the STA.
     Maximum number of peer links (0-255; default: 99)
   - =mesh_max_inactivity= 
     This timeout value is used in mesh STA to clean up inactive
     stations.
     Timeout in seconds to detect STA inactivity (default: 300
     seconds)
   - =cert_in_cb= 
     This controls whether peer certificates for authentication server
     and its certificate chain are included in EAP peer certificate
     events.
     This is enabled by default.
   - =fast_reauth= 
     快速重新认证。默认情况下，对于所有支持的EAP方法，快速重新认证是开
     启的。
   - =opensc_engine_path= 
     OpenSSL Engine support, 默认情况下，没有加载任何Engine.
   - =openssl_ciphers= 
     OpenSSL cipher string
   - =load_dynamic_eap=
     Dynamic EAP methods. 当EAP方法是编译成单独的so文件时，需要配置该
     项。默认情况下，EAP方法是静态编译到 =wpa_supplicant= 。
   - =driver_param=
     驱动接口参数。
   - =country=
     国家码
   - =dot11RSNAConfigPMKLifetime=
     PMKSA最大存活时间，默认是43200秒.
   - =dot11RSNAConfigPMKReauthThreshold= 
     重新认证的阀值(PMKSA值的百分比), 默认是70.
   - =dot11RSNAConfigSATimeout= 
     安全关联的超时，默认是60秒。
   - =uuid= 
     Universally Unique IDentifier, 如果没有配置，会根据MAC地址来产生。
   - =device_name= 
     设备名，字符串。
   - =manufacturer=
     设备生产商， 字符串。
   - =model_name=
     设备模式。
   - =model_number= 
     模式编号。
   - =serial_number=
     序列号。
   - =device_type=
     主设备类型，格式：<categ>-<OUI>-<subcateg>
   - =os_version=
     操作系统版本号
   - =config_methods=
     WPS支持的方法。
   - =wps_cred_processing=

     0: process received credentials internally (default)

     1: do not process received credentials; just pass them over
      =ctrl_iface= to external program(s)

     2: process received credentials internally and pass them over
     ctrl_iface to external program(s)
   - =wps_vendor_ext_m1= 
     Vendor attribute in WPS M1
   - =wps_priority=
     Priority for the networks added through WPS
   - =bss_max_count=
     Maximum number of BSS entries to keep in memory
   - =autoscan= 
     Automatic scan
   - =filter_ssids= 
     过滤SSID
     0： do not filter scan results (default)
     1： only include configured SSIDs in scan results/BSS table
   - =ext_password_backend=
     Password (and passphrase, etc.) backend for external storage
   - =p2p_disabled=
     禁用P2P功能。
   - =p2p_go_max_inactivity=
     检测STA是否活跃的超时值，默认是300秒。
   - =p2p_passphrase_len=
     GO随机产生的密码的长度，默认是8.
   - =p2p_search_delay=
     Extra delay between concurrent P2P search iterations
     默认值为：500ms.
   - =dtim_period=
     efault value for DTIM period
   - =beacon_int=
     Default value for Beacon interval
   - =ap_vendor_elements=
     Additional vendor specific elements for Beacon and Probe Response
     frames
   - =ignore_old_scan_res=
     Ignore scan results older than request
   - =scan_cur_freq=
     Whether to scan only the current frequency
     0: Scan all available frequencies. (Default)
     1: Scan current operating frequency if another VIF on the same
     radio is already associated.
   - =mac_addr=

     0 = use permanent MAC address

     1 = use random MAC address for each ESS connection

     2 = like 1, but maintain OUI (with local admin bit set)
   - =rand_addr_lifetime=
     随机MAC地址的存活时间，默认是60秒。
   - =preassoc_mac_addr=

     MAC address policy for pre-association operations

     0 = use permanent MAC address

     1 = use random MAC address

     2 = like 1, but maintain OUI (with local admin bit set)

    - =config_ssid.h= Definition of per network configuration items
    - =config.h= Definition of the =wpa_supplicant= configuration
    - =config.c= Configuration parser and common functions
    - =config_file.c= Configuration backend for text files (e.g.,
      =wpa_supplicant=.
** Cryptographic functions
     重点看下如何调用这些函数进行加密的

** driver interface
   一个新的驱动的注册主要是定义一个 =wpa_driver_ops= 结构体实例。 硬件
   的部分代码会通过这个结构体提供的一些回调函数来控制驱动/无线网卡。 
   
*** 基本机制研究

**** 如何通过 =wpa_supplicant= 向Driver发送命令。 
        这个流程很简单， =wap_supplicant= 是利用 =wpa_driver_ops= 注册
        的回调函数，来向Driver下达命令， 这些回调函数实际会通过
        netlink标准命令，将用户请求的命令传达到内核，并最终触发Driver
        向硬件下达命令。

**** =wpa_supplicant= 如休接收到底层Driver发送过来的事件   

     #+BEGIN_SRC plantuml :file ./images/2016/2016012001.png :cmdline -charset UTF-8
        title wpa_supplicant接收Driver上报事件的流程
        @startuml
        start
        :global_init;
        note right: 这个是在注册驱动提供的一个回调接口
        :nl80211_global_init;
        :wpa_driver_nl80211_init_nl_global;
        :process_global_event;
        #blue:do_process_drv_event;
        note right: 所有Driver上报的事件会通过些接口分发处理
        stop
        @enduml  
     #+END_SRC

     #+RESULTS:
     [[file:./images/2016/2016012001.png]]

*** 配置加密方法（TKIP/CCMP）
    如果是在Driver中实现的，必须提供一种配置的手段。

*** 漫游和扫描支持
*** 产生WPA IE
      WPA IE是在Driver中产生的还是在 =wpa_supplicant= 中产生的？
      
*** rfkill
** l2 packets
*** 链路层套接字 =PF_PACKET=
    Packet套接字用于在MAC层上收发原始数据帧，这样就允许用户在用户空间
    完成MAC之上各个层次的实现。
    Packet套接字的定义方式与传送层的套接字定义类似，如下：
    #+BEGIN_SRC c
      packet_socket=socket(PF_PACKET,int socket_type,int protocol);
    #+END_SRC


    其中 =socket_type= 有两种类型，一种为 =SOCK_RAW=,它是包含了MAC层头
    部信息的原始分组，当然这种类型的套接字在发送的时候需要自己加上一个
    MAC头部（其类型定义在 =linux</if_ether.h= 中，ethhdr），另一种是
    =SOCK_DGRAM= 类型，它是已经进行了MAC层头部处理的，即收上的帧已经去
    掉了头部，而发送时也无须用户添加头部字段。Protocol是指其送交的上层
    的协议号，如IP为0x0800，当其为 =htons(ETH_P_ALL)= （其宏定义为0）
    时表示收发所有的协议。创建好套接字后，就可以通过与UDP一样的
    recvfrom与sendto函数进行数据的收发，其目的地址结构为 =sockaddr_ll=
    ，这与传送层的地址结构定义是不一样的，其长度为20字节（在TCP/IP的链
    路层地址中使用了18字节），而传送层的地址结构长度为16字节。

    Sockaddr_ll结构如下：
    #+BEGIN_SRC c
      struct sockaddr_ll
      {
        unsigned short sll_family; /* 总是 AF_PACKET */
        unsigned short sll_protocol; /* 物理层的协议 */
        int sll_ifindex; /* 接口号 */
        unsigned short sll_hatype; /* 报头类型 */
        unsigned char sll_pkttype; /* 分组类型 */
        unsigned char sll_halen; /* 地址长度 */
        unsigned char sll_addr[8]; /* 物理层地址 */
      };
    #+END_SRC
*** =wpa_supplicant= 中 =l2_packet= 的初始化
    初始化函数函数在 =l2_packet_init= ，设置接收不同的LLC层数据包类型。 

    l2 packets的发送函数： =l2_packet_send=
    驱动接口中接收EAPOL Packet的代码如下：
   #+BEGIN_SRC c
     drv->eapol_sock = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_PAE));
     if (drv->eapol_sock < 0) {
             wpa_printf(MSG_ERROR, "nl80211: socket(PF_PACKET, SOCK_DGRAM, ETH_P_PAE) failed: %s",
                        strerror(errno));
             goto failed;
     }

     if (eloop_register_read_sock(drv->eapol_sock, handle_eapol, drv, NULL))
     {
             wpa_printf(MSG_INFO, "nl80211: Could not register read socket for eapol");
             goto failed;
     }

   #+END_SRC

    负责处理的函数是 =handle_eapol= 。
*** 管理帧发送和接收
    初始化RAW Socket，代码如下：
    #+BEGIN_SRC c
      static int hostap_init_sockets(struct hostap_driver_data *drv, u8 *own_addr)
      {
              struct ifreq ifr;
              struct sockaddr_ll addr;

              drv->sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
              if (drv->sock < 0) {
                      wpa_printf(MSG_ERROR, "socket[PF_PACKET,SOCK_RAW]: %s",
                                 strerror(errno));
                      return -1;
              }

              ...
                
              return linux_get_ifhwaddr(drv->sock, drv->iface, own_addr);
      }    
      (src/drivers/driver_hosap.c)
    #+END_SRC

    函数 =hostap_send_mlme= 发送管理帧，如发送 Probe Response. 
    =handle_frame= 用于处理接收到的管理帧或数据帧等。

** =hostapd_setup_bss=
   Initialize Per-BSS data structures.
   #+BEGIN_SRC plantuml :file ./images/2016/2016031501.png :cmdline -charset UTF-8
     @startuml
     start
     :hostapd_setup_interface;
     :setup_interface;
     :hostapd_setup_interface_complete;
     :hostapd_setup_bss;
     :ieee802_1x_init;
     if (执行成功?) then (yes)
     :eapol_auth_init;
     endif
     if (hapd->conf->wpa) then (yes)
     :hostapd_setup_wpa;
     :wpa_init;
     endif
     stop
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:./images/2016/2016031501.png]]

** State Machine
*** 状态机的定义 
    文件路径 src/utils.h
    此文件中定义了一些宏用于实现一个状态机
**** 总体说明
     首先，需要包含这个头文件，另外在实现文件中，有如下一些要求：
     1. 必须定义这个宏 =STATE_MACHINE_DATA= ，代表包含状态机变量的数据
        结构
     2. 定义宏 =STATE_MACHINE_DEBUG_PREFIX= 已保证输出该状态机相关的打
        印消息时，有相关的前缀信息出来。
     3. 宏 =SM_ENTRY_MA= 用于定义一组共享一个数据结构的状态机。
     4. 宏 =STATE_MACHINE_ADDR= 定义到指向在调试输出中的MAC地址
     5. 宏 =SM_ENTRY_M= 用于定义一组类似的状态机，只是不包含这些额外的
        调试信息。
**** 主要宏
     1. =SM_STATE=
        用于声明一个状态机的函数。 当调用 =SM_ENTER=,
        =SM_ENTER_GLOBAL= ，进入当前状态。
        #+BEGIN_SRC c
          #define SM_STATE(machine, state) \
          static void sm_ ## machine ## _ ## state ## _Enter(STATE_MACHINE_DATA *sm, \
                  int global)        
        #+END_SRC
     2. =SM_ENTRY=
        状态机函数入口点，通常位于函数体的开头处。
        #+BEGIN_SRC c
          #define SM_ENTRY(machine, state) \
          if (!global || sm->machine ## _state != machine ## _ ## state) { \
                  sm->changed = TRUE; \
                  wpa_printf(MSG_DEBUG, STATE_MACHINE_DEBUG_PREFIX ": " #machine \
                             " entering state " #state); \
          } \
          sm->machine ## _state = machine ## _ ## state;        
        #+END_SRC
     3. =SM_ENTRY_M=
        一组状态机的入口函数，定义与 =SM_ENTRY= 一样。
     4. =SM_ENTRY_MA=
        与 =SM_ENTRY_M= 一样，只是在调试信息中加入了MAC地址信息。
     5. =SM_ENTER=
        将状态机从一个状态转入另一个状态。
        #+BEGIN_SRC c
          #define SM_ENTER(machine, state) \
          sm_ ## machine ## _ ## state ## _Enter(sm, 0)        
        #+END_SRC
     6. =SM_ENTER_GLOBAL= 
        #+BEGIN_SRC c
          #define SM_ENTER_GLOBAL(machine, state) \
          sm_ ## machine ## _ ## state ## _Enter(sm, 1)        
        #+END_SRC
     7. =SM_STEP=
        声明一个状态机的step函数
        #+BEGIN_SRC c
          #define SM_STEP(machine) \
          static void sm_ ## machine ## _Step(STATE_MACHINE_DATA *sm)        
        #+END_SRC
     8. =SM_STEP_RUN=
        调用一个状态机的step函数
        #+BEGIN_SRC c
          #define SM_STEP_RUN(machine) sm_ ## machine ## _Step(sm)        
        #+END_SRC
*** WPA/WPA2 

**** wpa state machine初始化
***** L2 Packet (EAPOL包)处理
        创建了一个链路层的套接字(=driver_nl802.11.c=)：
        #+BEGIN_SRC c
          drv->eapol_sock = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_PAE));       
        #+END_SRC
        监听并处理EAPOL链路层数据包
        #+BEGIN_SRC c
           if (eloop_register_read_sock(drv->eapol_sock, handle_eapol, drv, NULL))
           {
                   printf("Could not register read socket for eapol\n");
                   goto failed;
           }
                 
        #+END_SRC

        处理流程：
         #+BEGIN_SRC plantuml :file ./images/2016/2016011801.png :cmdline -charset UTF-8
           @startuml
           start
           :nl802.11驱动初始化;
           :handle_eapol ;
           note right
           在802.11驱动初始化时，注册了处理EAPOL数据包的
           回调函数handle_eapol
           end note
           :drv_event_eapol_rx;
           :wpa_supplicant_event;
           :wpa_supplicant_assoc;
           :wpa_supplicant_rx_eapol;
           stop
           @enduml
         #+END_SRC

         #+RESULTS:
         [[file:./images/2016/2016011801.png]]

        1. evnets.c  
           =EVENT_EAPOL_RX=
           在Association之前收到EAPOL包，会先缓存起来，等到Association成
           功后，再处理。
        2. =wpa_supplicant.c=
           

        =wpa_supplicant_set_state=
**** wpa Authenticator
     在 =hostapd_setup_wpa= 中会初始化 =wpa_authenticator=
     (wpa_auth_glue.h), 标记为： =WPA_PROTO_WPA= =WPA_PROTO_RSN=
**** WPA supplicant
     WPA功能代码如下：
     - =wpa.c and wpa.h= WPA state machine and 4-Way/Group Key Handshake
       processing
     - =preauth.c and preauth.h= PMKSA caching and pre-authentication
       (RSN/WPA2)
     - =wpa_i.h= Internal definitions for WPA code; not to be included
       to other modules.
*** EAPOL
    IEEE 802.1X-2004 - Supplicant - EAPOL state machines
**** EAPOL supplicant
     =eapol_supp_sm.c and eapol_supp_sm.h= EAPOL状态机和IEEE 802.1X处理。
**** EAPOL Authenticator
     在 =ieee802_1x_init= 会初始化 =eapol_authenticator= 

*** EAP
    EAP Peer State Machine & EAP Server State Machine, RFC4137 & RFC3748

**** EAP peer
      这个模块是个相对独立的模块，可单独使用。
      相关文件说明如下：
      - =eap.c and eap.h= EAP状态机和方法接口。
      - =eap_defs.h= 通用的EAP定义
      - =eap_i.h= EAP状态机和EAP方法的内部定义。
      - =eap_sim_common.c and eap_sim_common.h= =EAP-SIM= 和 =EAP-AKA= 的公用代
        码。
      - =eap_tls_common.c and eap_tls_common.h= =EAP-PEAP, EAP-TTLS, and
        EAP-FAST= 公用代码
      - =eap_tlv.c and eap_tlv.h= =EAP-PEAP= 和 =EAP-FAST= 的 =EAP-TLV=
        代码。
      - =eap_ttls.c and eap_ttls.h= EAP-TTLS代码。
      - =eap_pax.c, eap_pax_common.h, eap_pax_common.c=  =EAP-PAX= 代码
      - =eap_psk.c, eap_psk_common.h, eap_psk_common.c= =EAP-PSK= 代码
      - =eap_sake.c, eap_sake_common.h, eap_sake_common.c= =EAP-SAKE= 代
        码
      - =eap_gpsk.c, eap_gpsk_common.h, eap_gpsk_common.c= =EAP-GPSK= 代
        码
      - =eap_aka.c, eap_fast.c, eap_gtc.c, eap_leap.c, eap_md5.c,
        eap_mschapv2.c, eap_otp.c, eap_peap.c, eap_-sim.c, eap_tls.c=
        其他EAP方法实现

**** EAP Server

*** wpa statemachine状态变化
     设置当前状态： =wpa_supplicant_set_state=
     获取当前状态： =wpa_supplicant_get_state=

     访问当前状态机的状态(公供wpa状态机内部调用)： 
     1. 获取当前状态机的状态：  =wpa_sm_get_state=
     2. 设置当前状态机的状态:  =wpa_sm_set_state= 
        
* =wpa_supplicant= 功能模块分析
** P2P
*** 数据结构分析与初始化流程 
**** 主要数据结构
     
**** 初始化流程
     当Driver支持一个非网络接口的P2P Device接口时,
     #+BEGIN_SRC c
       /* Driver supports a dedicated interface for P2P Device */
       #define WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE           0x20000000     
     #+END_SRC
     先做 =wpa_drv_if_add= ，然后进行 =wpa_supplicant_add_iface= 。
     否则，则从 =wpa_supplicant_add_iface= 开始执行。

     #+BEGIN_SRC plantuml :file ./images/2016/2016020101.png :cmdline -charset UTF-8
       @startuml
       :wpa_supplicant_add_iface;
       :wpa_supplicant_init_iface;
       if (iface->p2p_mgmt = 1) then(yes)
       :wpas_p2p_init;
       endif
       :初始化struct p2p_config;
       note right: 注册了与p2p相关的一些回调函数
       :p2p_init;
       note right: 初始化了一个struct p2p_data数据结构
       @enduml
     #+END_SRC

     #+RESULTS:
     [[file:./images/2016/2016020101.png]]

     在 =p2p_init= 函数中，同时也注册了一个 循环超时检测函数
     =p2p_expiration_timeout= ，这个函数会周期性检查当前P2P Peers端是
     否处于活跃状态（当我们是GO的时候，需要做这样的检查，以维护peer
     device list列表）

*** 基本连接流程

**** 一般连接过程
     
      1. 首先，P2P设备要能发现对方，会通过扫描来进行：要么在1，6，11信道
         上主动发送Probe Request来侦测P2P设备，要么停留在某个信息侦测
         Beacon或Probe Reqeust帧。
      2. 在建立P2P组前，可以询问被发现的P2P设备支持哪些服务。
      3. 当决定跟被发现的P2P设备连接时，可以邀请一个已经加一个了某个P2P
         组的P2P设备加入一个新的P2P组，或与一个未连接的P2P设备通过GO协
         商过程形成一个新的P2P组。
         会经历GO-NEGOTIATION-REQUEST和GO-NEGOTIATION-RESPONSE两步交互
         过程，一旦协商完成，发起方会发送一个
         GO-NEGOTIATION-CONFIRMATION，然后两个设备都会切换到协商好的信道
         上去进行通信。
         GO会不停地发送Beacon帧，携带协商的BSSID信息，且 =group
         formation bit= 会置为1，因为此时，P2P成组过程还没有结束。
      4. 然后是 =Provisioning= 阶段开始，P2P Client会连接GO，通过WPS协
         议来交换 =credentials= 信息，实质上是一些EAP消息的交互（M1~M8）  
         当加入一个现存的P2P组时，或为了加快 =provisioning= 阶段，设备
         可以在进行Group协商之前执行 =Provision Discovery
         request/response= . 如果不这样，GO Negotiation会失败。必须在后
         续重新启动协商过程。
      5. 之后 ，会进行关联，4-way握手过程，以交换密钥。 之后，GC会向GO
         请求一个IPv4的地址，GO需要实现DHCP服务器的功能。

         为了免掉每次Group创建过程中，需要输入PIN码的麻烦，可以将P2P组
         设为 =persistent= 的，这样它会存储 =credentials= 信息，并在适
         当的时候重新连接 。 

         http://processors.wiki.ti.com/index.php/OMAP_Wireless_Connectivity_NLCP_WiFi_Direct_Configuration_Scripts

       #+CAPTION: 两个P2P设备A，B执行P2P连接时，帧交换的过程
       #+BEGIN_SRC plantuml :file ./images/2016/2016012501.png :cmdline -charset UTF-8
         @startuml
         A -> B : (1)Probe requests with P2P IE on all channels.
         note right
         At first both devices will enter the scan phase, and send
         Probe requests with P2P IE on all channels.

         After a random time one of them will start to listen on one of the
         social channels (1, 6 or 11) and finally receive a probe request
         from the other station. It will reply with: Probe response with P2P IE
         end note
         B -> A : (2)Probe response with P2P IE
         note right
         Device A reports "Another device found" to the user or
         managing application. Now an optional service discovery
         exchange can happen:
         end note
         A -> B: (a) Service Discovery query
         B -> A: (b) Service Discovery response
         note right: Then group formation begins
         A -> B: (3) GO Negotiation request
         note right
         B reports this to the user and will wait for the input,
         which we assume to timeout in this case.
         end note
         B -> A: (4) GO Negotiation response (fail)
         note right
         Optionally, instead of having the first GO Negotiation fail,
         the devices could have used Provision Discovery before group
         formation, but this does not change the number of total frames
         exchanged
         end note
         A -> B: (3) Provision Discovery request
         B -> A: (4) Provision Discovery response
         A -> B: (5) GO Negotiation request
         note right
         In the end we suppose the user on B has allowed the connection.
         end note
         B -> A: (6) GO Negotiation response (success)
         A -> B: (7) GO Negotiation confirmation
         note right
         Now one device becomes GO and the other client, Let's
         assume B is the GO
         end note
         B -> A: (8) GO sends beacons (formation bit = 1)
         A -> B: (9) Authentication 1
         B -> A: (10) Authentication 2
         A -> B: (11) Association request
         B -> A: (12) Association response
         note right
         Now the "provisioning" phase begins, which is a WPS exchange
         of usually 8 frames. We don't go into the details of the WPS
         protocol here.

         (13) (14) (15) (16) (17) (18) (19) (20)

         Next the GO starts to send beacons with the formation bit set to 0.

         end note

         B -> A: (21) GO beacon (formation bit = 0)
         note right
         The client re-authenticates and re-associates with the new credentials:
         end note

         A -> B: (22) Authentication 1
         B -> A: (23) Authentication 2
         A -> B: (24) Association request
         B -> A: (25) Association response

         note right
         Now the RSN 4-way handshake begins, and again we
         don't go into the details of RSN:
         end note
         B -> A: (26) ANonce
         A -> B: (27) SNonce + MIC
         B -> A: (28) GTK + MIC
         A -> B: (29) ACK

         @enduml
       #+END_SRC

       #+RESULTS:
       [[file:./images/2016/2016012501.png]]

**** 收到Invitation Request的交互过程
     1. 当前设置处于 =P2P_Find= 阶段时，如果收到 =Invitation Request=
        Action帧，即 =P2P: Received Invitation Request from
        86:38:38:b0:ff:ee (freq=2462)= ，则首先会解析该Action帧携带的一些
        信息，然后将该设备添加到设备列表中，并报告有新的设备发现。
     2. 创建一个p2p接口。 
        =P2P: Create a new interface p2p-p2p0-0 for the group=
        =nl80211: Create interface iftype 9 (P2P_GO)=
     3. 发送 =Invitation Response= Action帧给对端。并回调
        =p2p_inviation_resp_cb= , 它会调用 =wpas_invitation_received=
        。
     4. 调用 =p2p_stop_find= 。




**** Driver 当GC时的交互过程：

     #+BEGIN_EXAMPLE
       1. CFG80211_PKT: RX P2P_PROVISION_REQ 11
       2. CFG80211_PKT: TX P2P_PROVISION_RSP 11
       3. CFG80211_PKT: RX GO_NEGOCIACTION_REQ 11
       4. CFG80211_PKT: TX GO_NEGOCIACTION_RSP 11
          这时，会启动Virutal Inferace： RTMP_CFG80211_VirtualIF_Init
          
       5. CFG80211_OpsRemainOnChannel   listen
       6. CFG80211_PKT: TX GO_NEGOCIACTION_REQ 11
       7. CFG80211_PKT: RX GO_NEGOCIACTION_RSP 11
       8. CFG80211_PKT: TX GO_NEGOCIACTION_CONFIRM 11
          CFG80211_VirtualIF_Open, 会出现："(ApCliIfUp) ApCli can't startup Due to CFG80211 No connect yet."
       9. CFG80211_OpsConnect
          80211> Connect bssid 16:f6:5a:ac:92:0e
          APCLI Connection onGoing.....
          AP_CLI WPS Connection onGoing.....
          80211> APCLI CONNECTING SSID = DIRECT-si-
          Set_ApCli_Enable_Proc::(enable = 1)
          (ApCliIfDown) ApCli interface[0] startdown.
          80211> APCLI CONNECTING SSID = DIRECT-si-
          80211> CFG80211_OpsStaChg ==>
          80211> Change STA(00:00:00:00:00:00) ==>
          80211> CFG80211_OpsStaChg ==>
          80211> Change STA(00:00:00:00:00:00) ==>
          80211> CFG80211_OpsStaChg ==>
          80211> Change STA(00:00:00:00:00:00) ==>
          80211> CFG80211_OpsStaChg ==>
          80211> Change STA(00:00:00:00:00:00) ==>
          (ApCliIfUp) ApCli interface[0] startup.
          (ApCliCtrlJoinReqAction) Start Probe Req.
          ApCli SYNC - Start Probe the SSID  on channel =1
          SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
          = 1
          PeerBeaconAtJoinAction HT===>Central Channel = 1, Control
          Channel = 1,  .
          APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
          APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
          APCLI_ASSOC - Send ASSOC request...
          ApCliPeerAssocRspSanity() found wfd ie in assoc response frame,
          it's wfd connect.
          APCLI_ASSOC - receive ASSOC_RSP to me (status=0)
          ApCliPeerAssocRspAction:: recv peer ASSOC RSP from
          16:f6:5a:ac:92:0e.    bP2pClient = 1
          ApCliAssocPostProc===> 11n HT STA
          !!! APCLI LINK UP - IF(apcli0) AuthMode(0)=OPEN,
          WepStatus(1)=NONE !!!
          MacTableInsertEntry - allocate entry #2, Total= 1
          80211> CFG80211_OpsStaChg ==>
          80211> Change STA(16:F6:5A:AC:92:0E) ==>
          =WPS-Start=
          Receive EAP-Packet frame, TYPE = 0, Length = 5
          CFG80211 EAPOL Indicate_Legacy_Packet
          CFG80211_PKT: RX ACTION Frame 1
          CFG80211_PKT: P2P_CHECK ACTION Frame 1
          80211> CFG80211_OpsDisconnect ==>
          80211> ReasonCode = 3
          AUTH - Send DE-AUTH request (Reason=3)..
          !!! APCLI LINK DOWN - IF(apcli0)!!!   
          =WPS-End=
          ++++++++ ApCliLinkDown::  Keep BssTable on Channel
          = 1. ++++++++      BSSID = [16:f6:5a:ac:92:0e].  p2p_bssid =
          [16:f6:5a:ac:92:0e].
          80211> CFG80211_LostGoInform ==> 
          (ApCliIfDown) ApCli interface[0] startdown.

          80211> CFG80211_OpsConnect ==>

          =4-way-handshake=
          80211> Connect bssid 16:f6:5a:ac:92:0e
          (ApCliIfUp) ApCli interface[0] startup.
          (ApCliCtrlJoinReqAction) Start Probe Req.
          SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
          = 1
          ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
          Scanning!!
          APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
          APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
          APCLI_ASSOC - Send ASSOC request...
          ApCliMlmeAssocReqAction:: APCLI WPA_ASSOC_IE FROM SUPPLICANT
          (ApCliCtrlAssocReqTimeoutAction) Assoc Req Timeout.

          (ApCliIfUp) ApCli interface[0] startup.

          (ApCliCtrlJoinReqAction) Start Probe Req.
          SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
          = 1
          ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
          Scanning!!
          APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
          Deauth: 7e:b2:32:e7:7c:25, 16:f6:5a:ac:92:0e
          APCLI AUTH_RSP - receive DE-AUTH from our AP
          APCLI AUTH - AuthTimeout
          (ApCliIfUp) ApCli interface[0] startup.
          (ApCliCtrlJoinReqAction) Start Probe Req.
          SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
          = 1
          ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
          Scanning!!

          APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
          APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
          (ApCliCtrlAuthRspAction) Auth Rsp Success.
          APCLI_ASSOC - Send ASSOC request...
          APCLI_ASSOC - receive ASSOC_RSP to me (status=0)
          ApCliPeerAssocRspAction:: recv peer ASSOC RSP from
          16:f6:5a:ac:92:0e.    bP2pClient = 1

          !!! APCLI LINK UP - IF(apcli0) AuthMode(7)=WPA2PSK,
          WepStatus(6)=AES !!!

          MacTableInsertEntry - allocate entry #2, Total= 1

          Receive EAPOL-Key frame, TYPE = 3, Length = 95
          CFG80211 EAPOL Indicate_Legacy_Packet
          80211> CFG80211_OpsKeyAdd ==>
          AsicAddSharedKeyEntry BssIndex=8, KeyIdx=1

          !!!P2P Group STARTED

          DHCP
          DHCP_DISCOVER
          DHCP_OFFER
          DHCP_REQUEST
          DHCP_ACK
     #+END_EXAMPLE
    
**** Driver当GO时的交互过程：
     #+BEGIN_EXAMPLE
                  
       1. P2P Listen  
          CFG80211_PKT: ROC CHANNEL_LOCK 11
          CFG80211_PKT: TX ProbeRsp Frame 11
          CFG80211_PKT: TX ProbeRsp Frame 11

       2. Receive P2P Invite
          CFG80211_PKT: RX P2P_INVITE_REQ 11
          CFG80211_PKT: TX P2P_INVITE_RSP 11

       3. CFG80211_PKT: RX GO_NEGOCIACTION_REQ 11

       4. CFG80211_PKT: TX GO_NEGOCIACTION_REQ 1

       5. CFG80211_PKT: RX GO_NEGOCIACTION_RSP 1

       6. CFG80211_PKT: TX GO_NEGOCIACTION_CONFIRM 1

       7. GroupNegotiatioCFG80211_VirtualIF_Open: ===> 8,p2p-p2p0-2
          rocessMessage   (ApCliIfUp) ApCli can't startup Due to
          CFG80211 No connect yet.
          ==> RTMP_CFG80211_VirtualIF_CancelP2pClient.
          ==> RTMP_CFG80211_VirtualIF_CancelP2pClient HIT.
          80211> Change to IFTYPE_AP 3!
          80211> Change the Interface to AP Mode
          80211> CFG80211_OpsStaDel ==>
          Deauthenticate all stations!

       8. 80211> Set the channel in AP Mode
          80211> CFG80211DRV_OpsBeaconSet ==> 1
          New AP BSSID 7e:b2:32:e7:7c:25
          CFG80211_PKT: TX ProbeRsp Frame 11
          AUTH - MBSS(0), Rcv AUTH seq#1, Alg=0, Status=0 from
          [wcid=255]86:38:38:b0:7f:ee
          AUTH_RSP - Send AUTH response (SUCCESS)...
          ASSOC - MBSS(0), receive ASSOC request from
          86:38:38:b0:7f:ee
          SSOC - Send ASSOC response (Status=0)...
          =WPS=
          ####### Send L2 Frame Mac=86:38:38:b0:7f:ee
          CFG80211_PKT: RX ACTION Frame 11
          CFG80211 EAPOL Indicate_Legacy_Packet

       9. P2P_GROUP_STARTED_STR
          ASSOC - receive DIS-ASSOC(seq-1765) request from
          86:38:38:b0:7f:ee, reason=8
          
          AUTH_RSP - Send AUTH response (SUCCESS)...
          ASSOC - Send ASSOC response (Status=0)...
          =4-way handshake=
          ####### Send L2 Frame Mac=86:38:38:b0:7f:ee
     #+END_EXAMPLE

**** Action帧的接收
         
         #+CAPTION: 接收Action帧的流程
         #+BEGIN_SRC plantuml :file ./images/2016/2016012901.png :cmdline -charset UTF-8
           title  wpa_supplican处理公共Action帧的流程
           @startuml
           start
           :process_bss_event;
           note right: nl80211_init_bss时，会注册回调函数: process_bss_event
           :mlme_event;
           note right: 当收到NL80211_CMD_FRAME, NL80211_CMD_FRAME_TX_STATUS时处理
           :mlme_event_mgmt;
           note right: 收到Action帧 NL80211_CMD_FRAME
           :wpa_supplicant_event;
           note right: 传递EVENT_RX_ACTION事件
           #Blue:wpas_p2p_rx_action;
           note right: 收到p2p Action帧时的入口函数
           :p2p_rx_action;
           :p2p_rx_action_public;
           note right: WLAN_PA_VENDOR_SPECIFIC
           :p2p_rx_p2p_action;
           note right
           主要处理：
           1. P2P_GO_NEG_REQ
           2. P2P_GO_NEG_RESP
           3. P2P_GO_NEG_CONF
           4. P2P_INVITATION_REQ
           5. P2P_INVITATION_RESP
           6. P2P_PROV_DISC_REQ
           7. P2P_PROV_DISC_RESP
           8. P2P_DEV_DISC_REQ
           9. P2P_DEV_DISC_RESP
           end note
           stop
           @enduml
         #+END_SRC

         #+RESULTS:
         [[file:./images/2016/2016012901.png]]

**** Action帧的发送

        Action帧发送后，Driver会反馈发送的状态，即发送成功与否。

        通过 =struct p2p_cfg= 的回调接口： =send_action= ， 实际注册的
        函数为： =wpas_send_action= , 该函数会调用
        =offchannel_send_action= ，并注册了回调函数 :
        =wpas_p2p_send_action_tx_status= ， 通过该接口，将发送Action帧
        的结果反馈上来。底层是通过  =EVENT_TX_STATUS= 消息来通知的，通
        过调用 =offchannel_send_action_tx_status= 来回调注册的函数。
        
        #+BEGIN_SRC plantuml :file ./images/2016/2016012902.png :cmdline -charset UTF-8
          @startuml
          start
          :wpa_supplicant_event;
          note right: 收到EVENT_TX_STATUS事件
          :offchannel_send_action_tx_status;
          :wpas_p2p_send_action_tx_status
          note right: 注册的pending_action_tx_status_cb
          :p2p_send_action_cb;
          note right: 在这个函数中，会调用不同的状态注册的回调函数
          stop
          @enduml
        #+END_SRC

        #+RESULTS:
        [[file:./images/2016/2016012902.png]]

*** p2p管理

   当 =wpa_s->drv_flags= & =WPA_DRIVER_FLAGS_P2P_MGMT= 为真时，代表相关的P2P
   管理操作会由Driver去实现。上层对P2P的一些操作，最终会透过netlink发
   送给Driver。

   当然，如果Driver并没有实现p2p管理的相关工作，则会在
   =wpa_supplicant= 这层来做。目前从代码看来，p2p管理相关的工作没有放到Driver中去做。

   =wpa_supplicant= 在文件 =p2p_supplicant.c= 这个文件中注册了许多p2p管理相关
   的函数接口。

*** Go创建
    入口函数： =wpa_driver_nl80211_set_ap= 
    两个相关的NL80211命令：
    - =NL80211_CMD_NEW_BEACON=
    - =NL80211_CMD_SET_BSS=
*** socket control interface
    - =p2p_find=  
      | Command                                                    | Description                                            |
      |------------------------------------------------------------+--------------------------------------------------------|
      | =p2p_find= [timeout (seconds)] [type <social \ progressive>] [dev_id=] [delay=] | Enables discovery – start sending probe request frames | 
      #+TBLFM: $1=p2p_find= [timeout (seconds)] [type <social \ progressive>] [dev_id=] [delay=]

      p2p_find默认的行为是开始做一次全信道扫描，然后扫描特定的信道。 
      参数说明如下：
      - 当type=social时，只会扫描社会信息，会跳过第一次全信道扫描。

      - 当type=progressive时，行为类似默认情况下的行为，只不过在每一次
        Search状态的回合中，依次扫描一个信道。

      - dev_id : 可以指定单个要扫描的对端设备。

      - delay: 是一个延时值。 


      当接受到 =p2p_find= 命令时，会进入入口函数： =p2p_ctrl_find= ，
      此时会决定两个参数：
      1. 扫描的类型
      2. 延时扫描的时间，即等待多久后，进行p2p find的动作。

      接下来会进入 =wpas_p2p_find= 函数，如果当前的SSID的模式为
      =WPAS_MODE_P2P_GO= 或 =WPAS_MODE_P2P_GROUP_FORMATION= ， 会停止
      p2p find的动作。 

      然后，会清掉一些未决的Action帧的传输动作。 如果P2P管理的功能实现
      在 driver 层，则直接进入 函数： =wpa_drv_p2p_find= ， 通过
      NL80211触发Driver直接 p2p find动作。 否则，则会进入 =p2p_find=
      ， 在此之前，会取消规划的扫描动作。 

      这些函数会准备执行 p2p find 所需要的一些参数 ，然后调用到
      p2p->cfg->p2p_scan 回调接口。 它有三种返回值：
      - 0: 扫描请求发送成功，设置扫描超时时间。
      - 1: 扫描请求失败，会等待上一个扫描动作完成后，再进行尝试，当前
        P2P状态机置为： =P2P_SEARCH_WHEN_READY= , 表示有个未决的扫描动
        作。相关函数： =p2p_search_pending=
        =p2p_other_scan_completed= 
      - 其他值： 扫描请求失败。 

      在 =p2p_supplicant.c= 文件中，定义了p2p 初始化的函数，里面有定义
      对应的回调接口： =wpas_p2p_scan= 。  在该函数中，会通过
      =wpa_drv_scan= 将扫描请求发送给Driver， 并指定扫描结果的处理回回
      调接口： =wpas_p2p_scan_res_handler= 
  
    - =p2p_stop_find=
      | Command       | Description                                                                       |
      |---------------+-----------------------------------------------------------------------------------|
      | =p2p_stop_find= | Stops discovery, or whatever you are doing (listen mode, connection process etc.) |
    - =p2p_connect=
      | Command                                                                   | Description                                                                    |
      |---------------------------------------------------------------------------+--------------------------------------------------------------------------------|
      |                                                                           | =GO_intent= – initiate connection to another device (using entered group intent) |
      | =p2p_connect= <device address> <PBC \ PIN> [ =GO_intent= =<0-15> \ auth \ join] | Auth – WPS authorize incoming connection                                       |
      |                                                                           | Join – connect to an existing GO                                               |
      |                                                                           | No input – initiate connection using default GO intent                         |

      这个命令直接会入口函数是 =p2p_ctrl_connect= ， 在解析
      =p2p_connect= 命令的参数后， 会进入  =wpas_p2p_connect= ，里面会
      执行一些重要的步骤：
      - =wpas_p2p_add_group_interface= 创建P2P虚拟接口
      - =wpas_p2p_auth_go_neg= 只确认协商时使用的信息
      - =wpas_p2p_start_go_neg= 开始 GO NEGOTIATION。

      在wps完成后，会启动重新关联过程,标记所有网络为禁用状态，从而触发
      Roaming过程：
      :wpas_wps_temp_disable(wpa_s, selected);
      :wpa_s->reassociate = 1;

    - =p2p_listen=
      | Command                        | Description        |
      |--------------------------------+--------------------|
      | =P2p_listen= [timeout (seconds)] | Enable listen mode |

      Listen状态可能不会立即开始，因为可能会有其他未决的操作正在进行，
      一旦进入Listen状态，会调用p2p_listen_cb()函数通知P2P模块。一旦退
      出Listen状态，会调用p2p_listen_end()函数通知P2P模块已经不再处于
      Listen状态了。

      =p2p_listen= 流程分析：
      应用程序进入Miracast后，一般会调用 =p2p_listen= 命令，监听附近的
      WFD Source设备， 大致流程如下：
      #+BEGIN_SRC plantuml :file ./images/2016/2016061001.png :cmdline -charset UTF-8
        title =p2p_listen= 流程
        @startuml
        start
        :上层应用下达P2P_LISTEN命令;
        :p2p_ctrl_listen;
        #Blue:wpas_p2p_listen;
        note right
        如果默认情况下，没有传递超时时间，或超时时间为0，
        则默认执行p2p_listen的时间为一个小时
        end note
        :wpa_s->p2p_long_listen;
        note right
        设置初始值为0， 这个值会决定在当前一轮
        remain on channel结束后，是否进入下一轮remain on channel.
        end note
        :p2p_stop_find;
        :wpas_p2p_listen_start;
        note right
        将p2p listen命令通过netlink传递给驱动，
        并将p2p state设置为LISTEN ONLY。
        end note
        split
        :p2p_listen;
        :start_listen;
        :wpas_start_listen;
        :wpas_start_listen_cb;
        :wpa_drv_remain_on_channel;
        split again
        :设置p2p_long_listen的值;
        note right
        如果当前设置的超时时间大于Driver一次在某个
        Channel上的最大remain on channel的时间，
        则设置p2p_long_listen，表示将要执行至少一
        次以上的p2p listen操作。 Driver在收到
        p2p listen请求后，会发生REMAIN_ON_CHANNEL
        通知上层已经进入某个Channel监听，当监听结束时，
        会发送一个CANCEL_REAMIN_ON_CHANNEL(EVENT_CANCEL_REMAIN_ON_CHANNEL)
        事件，将调用wpas_p2p_cancel_remain_on_channel_cb.
        end note
        end split
        stop
        @enduml      
      #+END_SRC

      #+RESULTS:
      [[file:./images/2016/2016061001.png]]

      在监听的过程，当驱动收到Probe Request请求后，会通过
      =cfg80211_rx_mgmt= 上报给内核，并最终通知给 =wpa_supplicant= ，
      调用路径为：
      #+BEGIN_SRC plantuml :file ./images/2016/2016061201.png :cmdline -charset UTF-8
        :mlme_event NL80211_CMD_FRAME
        :mlme_event_mgmt;
        :wpa_supplicant_event  EVENT_RX_MGMT
        :for p2p WLAN_FC_STYPE_PROBE_REQ
        :wpas_p2p_probe_req_rx;
        :p2p_probe_req_rx;
        :p2p_reply_probe;

      #+END_SRC

    - =p2p_group_remove=
      | Command                      | Description                                                                      |
      |------------------------------+----------------------------------------------------------------------------------|
      | =P2p_group_remove= <interface> | Remove device from group, return to device mode if acting as GO or autonomous GO |
    - =p2p_group_add=
      | Command                      | Description                                                                      |
      |------------------------------+----------------------------------------------------------------------------------|
      | =P2p_group_add=              | Become an autonomous GO                                                          |
      | =P2p_group_remove= <interface> | Remove device from group, return to device mode if acting as GO or autonomous GO |
    - =p2p_prov_disc=
      
    - =p2p_get_passphrase=
    - =p2p_serv_disc_req=
    - =p2p_serv_disc_cancel_req=
    - =p2p_serv_disc_resp=
    - =p2p_service_update=
    - =p2p_serv_disc_external=
    - =p2p_service_flush=
    - =p2p_service_add=
    - =p2p_service_del=
    - =p2p_reject=
    - =p2p_invite=
      | Command                    | Description               |
      |----------------------------+---------------------------|
      | =p2p_invite= <cmd> [address] | Send invitation to device |
    - =p2p_peers=
      | Command                | Description                                                                            |
      |------------------------+----------------------------------------------------------------------------------------|
      | =P2p_peers= [discovered] | Shows list of discovered peers (with ‘discovered’ – shows only fully discovered peers) |
    - =p2p_peer=
      | Command            | Description                                      |
      |--------------------+--------------------------------------------------|
      | =P2p_peer= <address> | Show detailed information about discovered peers |
    - =p2p_set=
    - =p2p_flush=
      | Command   | Description                                          |
      |-----------+------------------------------------------------------|
      | =P2p_flush= | Flush p2p_state, and clears the discovered peer list |
    - =p2p_presence_req=
    - =p2p_ext_listen=
    - =p2p_group_idle= 
      Maximum idle time in seconds for P2P group
      当一个p2p group建立起来后，GO等待GC连接的最大等待时间，或GC发现
      GO的最大超时时间。
      #+BEGIN_SRC c
        /*
         ,* How many seconds to try to reconnect to the GO when connection in P2P client
         ,* role has been lost.
         ,*/
        #define P2P_MAX_CLIENT_IDLE 10      
      #+END_SRC

      group timeout相关Log：
      #+BEGIN_EXAMPLE
        05-25 10:42:50.650 D/wpa_supplicant( 2963): P2P: Group idle timeout reached - terminate group
        05-25 10:42:50.650 D/wpa_supplicant( 2963): p2p0: Request to deauthenticate - bssid=00:00:00:00:00:00 pending_bssid=00:00:00:00:00:00 reason=3 state=SCANNING
        05-25 10:42:50.651 D/wpa_supplicant( 2963): TDLS: Tear down peers
        05-25 10:42:50.651 D/wpa_supplicant( 2963): p2p0: State: SCANNING -> DISCONNECTED
        05-25 10:42:50.651 D/wpa_supplicant( 2963): nl80211: Set p2p0 operstate 0->0 (DORMANT)
        05-25 10:42:50.651 D/wpa_supplicant( 2963): netlink: Operstate: ifindex=5 linkmode=-1 (no change), operstate=5 (IF_OPER_DORMANT)
        05-25 10:42:50.651 D/wpa_supplicant( 2963): CTRL_IFACE monitor sent successfully to /data/misc/wifi/sockets/wpa_ctrl_624-2\x00
        05-25 10:42:50.651 D/wpa_supplicant( 2963): EAPOL: External notification - portEnabled=0
        05-25 10:42:50.651 D/wpa_supplicant( 2963): EAPOL: External notification - portValid=0
        05-25 10:42:50.651 I/wpa_supplicant( 2963): P2P-GROUP-REMOVED p2p0 client reason=IDLE


        D/wpa_supplicant( 7409 7409): nl80211: Set supplicant port unauthorized for 00:00:00:00:00:00
        I/wpa_supplicant( 7409 7409): P2P-GROUP-REMOVED p2p-p2p0-0 client reason=GO_ENDING_SESSION
        D/wpa_supplicant( 7409 7409): CTRL_IFACE monitor send - hexdump(len=21): 2f 74 6d 70 2f 77 70 61 5f 63 74 72 6c 5f 37 36 32 2d 32 34 00
        D/wpa_supplicant( 7409 7409): P2P: Cancelled P2P group idle timeout
        D/wpa_supplicant( 7409 7409): P2P: Remove group interface p2p-p2p0-0
      #+END_EXAMPLE
*** nl80211 (p2p)
    - =NL80211_CMD_REMAIN_ON_CHANNEL=
    - =NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL=  

      This indicates to the device that it should stay on a given
      channel for a given time, to implement a P2P listen phase. Can
      also be canceled, since it is also used to implement off-channel
      TX for group negotiation or invitation

    - =NL80211_CMD_FRAME (previously NL80211_CMD_ACTION)=

      传输一个管理帧。

    - =NL80211_CMD_REGISTER_FRAME=

      通过nl80211，用户程序可以注册接收指定类型的管理帧。

*** 错误总结
      当Associate  Request失败后，会尝试5次

** bgscan (roaming) IAPP(Inter Access Point Protocol)

    =WPA_Supplicant= has a module that is called 'bgscan' which features
    a mode called 'simple'. This module can be configured to perform
    periodic background scans when the signal level drops under a
    certain level and when it finds a stronger AP during the scan it
    can 'roam' when the difference between the AP's is significant
    enough.

    I also found that this module was compiled, present and
    functioning by default. The only missing piece is that the
    configuration line in the wpa_supplicant.conf is missing
    preventing the bgscan module from loading. I added the line into
    the section for the relevant network:

    bgscan="simple:120:-75:600"

    The syntax for the configuration line is as follows and it should
    be placed in the network section rather than the global section:

    bgscan="simple:<short bgscan interval in seconds>:<signal strength
    threshold>:<long interval>"

    My bgscan simple line implies that if the signal is
    stronger/better than -75db it will perform a bgscan every 10
    minutes, if the signal is worse it will perform a scan every 2
    minutes.

    This is what a successful 'roam' looks like:
    #+BEGIN_EXAMPLE
      D/wpa_supplicant(  716): bgscan simple: Request a background scan
      D/wpa_supplicant(  716): Scan requested (ret=0) - scan timeout 30 seconds
      D/wpa_supplicant(  716): nl80211: Event message available
      D/wpa_supplicant(  716): nl80211: Scan trigger
      D/wpa_supplicant(  716): nl80211: Event message available
      D/wpa_supplicant(  716): nl80211: Scan aborted
      D/wpa_supplicant(  716): wlan0: Event SCAN_RESULTS (3) received
      D/wpa_supplicant(  716): nl80211: Associated on 2412 MHz
      D/wpa_supplicant(  716): nl80211: Associated with 68:7f:74:75:1c:7e
      D/wpa_supplicant(  716): nl80211: Received scan results (2 BSSes)
      D/wpa_supplicant(  716): nl80211: Survey data missing
      D/wpa_supplicant(  716): nl80211: Scan results indicate BSS status with 68:7f:74:75:1c:7e as associated
      D/wpa_supplicant(  716): wlan0: BSS: Start scan result update 527
      D/wpa_supplicant(  716): wlan0: BSS: Add new id 97 BSSID 00:1e:2a:21:f7:3d SSID 'pakjebakmeel24'
      D/wpa_supplicant(  716): CTRL_IFACE monitor send - hexdump(len=39): 2f 64 61 74 61 2f 6d 69 73 63 2f 77 69 66 69 2f 73 6f 63 6b 65 74 73 2f 77 70 61 5f 63 74 72 6c ...
      D/wpa_supplicant(  716): wlan0: New scan results available
      D/wpa_supplicant(  716): CTRL_IFACE monitor send - hexdump(len=39): 2f 64 61 74 61 2f 6d 69 73 63 2f 77 69 66 69 2f 73 6f 63 6b 65 74 73 2f 77 70 61 5f 63 74 72 6c ...
      D/wpa_supplicant(  716): bgscan simple: scan result notification
      D/wpa_supplicant(  716): wlan0: Selecting BSS from priority group 2
      D/wpa_supplicant(  716): wlan0: 0: 00:1e:2a:21:f7:3d ssid='pakjebakmeel24' wpa_ie_len=0 rsn_ie_len=20 caps=0x431 level=-71
      D/wpa_supplicant(  716): wlan0:    selected based on RSN IE
      D/wpa_supplicant(  716): wlan0:    selected BSS 00:1e:2a:21:f7:3d ssid='pakjebakmeel24'
      D/wpa_supplicant(  716): wlan0: Considering within-ESS reassociation
      D/wpa_supplicant(  716): wlan0: Current BSS: 68:7f:74:75:1c:7e level=-79
      D/wpa_supplicant(  716): wlan0: Selected BSS: 00:1e:2a:21:f7:3d level=-71
      D/wpa_supplicant(  716): wlan0: Saving prev AP info for roaming recovery - SSID ID: 1 BSSID: 68:7f:74:75:1c:7e
      D/wpa_supplicant(  716): wlan0: Request association: reassociate: 0  selected: 00:1e:2a:21:f7:3d  bssid: 68:7f:74:75:1c:7e  pending: 00:00:00:00:00:00  wpa_state: COMPLETED
      I/wpa_supplicant(  716): wlan0: EPBUG: Going to authenticate
    #+END_EXAMPLE

    https://android.googlesource.com/platform/external/wpa_supplicant_8/+/ics-plus-aosp/wpa_supplicant/bgscan_simple.c

** WPS
   在P2P GO与GC关联后，会进行WPS交互过程。交互时的一些信息会透过
   Association Request携带的IE信息来提供，如果底层驱动上报的
   Association Request中相关的IE信息为空，则WPS过程将会终止。
   在GO协议完成后，会开始WPS协商的过程。

   #+BEGIN_SRC plantuml :file ./images/2016/2016031007.png :cmdline -charset UTF-8
     @startuml
     :wpas_go_neg_completed;
     if (当前设备协商的角色是GO？) then (是)
     :wpas_start_wps_go;
     else (否)
     :wpas_start_wps_enrollee;
     endif
     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:./images/2016/2016031007.png]]

*** Enrollee
    此时双方会通过 P2P 接口地址进行交互。WPS具体使用的方式有PBC或者PIN
    的方式。

    #+BEGIN_SRC plantuml :file ./images/2016/2016031008.png :cmdline -charset UTF-8
      :wpas_start_wps_enrollee;
      if (use WPS ?) then (yes)
      :wpas_wps_start_pbc;
      else (no)
      :wpas_wps_start_pin;
      endif
    #+END_SRC

    #+RESULTS:
    [[file:./images/2016/2016031008.png]]

    下面我们主要看下WPS的交互过程：
    1. =wpas_wps_add_network=
       添加一个新的SSID， 设置其 =key_mgmt= 的值为 WPS， =eap= 值为WSC，
       =identity=  为 =WSC_ID_ENROLLEE= 。
    2. =wpa_config_set(ssid, "phase1", "\"pbc=1\"", 0)=
       设置网络参数： phase1的值。
    3. 注册WPS协商超时处理函数
       WPS超时时间为120秒。
    4. =wpas_wps_reassoc=
       它会执行如下几个重要动作：
       - 如果当前有连接到某个SSID，则断开。
       - 标记所有其他的网络为禁用状态，以触发重新关联动作。
       - 请求一次扫描， 专门扫描GO所在的频率。
         会构建WPS IE携带上Probe Request中。
    5. 等待扫描结果
       获得扫描结果后，会通过 =wpas_select_network_from_last_scan= 连
       接GO对应的SSID。 向GO发送关联请求。
    6. =wpa_supplicant_associate=
       向Driver发送Association Request的命令。然后调用
       =wpa_supplicant_rsn_supp_set_config= 通知 =wpa_sm= 状态机配置已
       经发生更改。 最后调用 =wpa_supplicant_initiate_eapol= 初始化
       =eapol_sm= 配置。
    7. 收到到Associate Response信息， =wpa_supplicant_event_assoc=
       成功关联上GO后，开始了WPS的交互过程。 GC首先发一笔：
       =eapol_sm_txStart= 将 =IEEE802_1X_TYPE_EAPOL_START= 包发出去。

*** Registar
    首先看下 =wpas_start_wps_go= 几个主要的过程：
    1. =wpas_copy_go_neg_results=
       复制协商后的参数信息。
    2. =wpa_config_add_network= 
       添加一个网络SSID.
    3. 配置新建的网络SSID的基本信息。
    4. 设置wpa_supplicant实例相关信息。
       设置回调接口： =p2p_go_configured=
    5. =wpa_supplicant_req_scan=
       发起一次扫描。
       
** SME
   SME was designed to be used when the driver does provide the
   separate authentication and association commands. 
   
   #+BEGIN_SRC c
     /* Driver provides separate commands for authentication and association (SME in
      ,* wpa_supplicant). */
     #define WPA_DRIVER_FLAGS_SME            0x00000020   
   #+END_SRC

** SoftAp
   hostapd是一个用户空间程序，实现了AP和认证服务器的功能。通过配置文件
   hostapd.conf 来修改一些Wifi参数。

   #+CAPTION: hostapd配置文件示例
   #+BEGIN_SRC sh
     interface=wlan0 
     driver=nl80211 
     ssid=woody_hostap
     hw_mode=g 
     channel=6 
     ieee80211n=1
     auth_algs=0
     wpa=1 
     wpa_passphrase=12345678
     wpa_key_mgmt=WPA-PSK 
     wpa_pairwise=TKIP
     wpa_ptk_rekey=600
   #+END_SRC

   
* wpa_supplicant代码修改

** add a conf parameter to start a GO as HT40 if allowed
   When specified in the conf file this parameter will make all
   invocations of p2p_group_add and p2p_connect behave as if "ht40"
   has been specified on the command line.
   This shouldn't do harm since regulatory constraints and driver
   capabilities are consulted anyway before starting HT40 mode.

   #+BEGIN_SRC sh
     ---
      wpa_supplicant/config.c      |    1 +
      wpa_supplicant/config.h      |   10 ++++++++++
      wpa_supplicant/config_file.c |    2 ++
      wpa_supplicant/ctrl_iface.c  |    4 ++--
      4 files changed, 15 insertions(+), 2 deletions(-)

     diff --git a/wpa_supplicant/config.c b/wpa_supplicant/config.c
     index be21029..3f64b03 100644
     --- a/wpa_supplicant/config.c
     +++ b/wpa_supplicant/config.c
     @@ -3000,6 +3000,7 @@ static const struct global_parse_data global_fields[] = {
             { INT_RANGE(p2p_intra_bss, 0, 1), CFG_CHANGED_P2P_INTRA_BSS },
             { INT(p2p_group_idle), 0 },
             { FUNC(p2p_pref_chan), CFG_CHANGED_P2P_PREF_CHAN },
     +       { INT(p2p_go_ht40), 0 },
      #endif /* CONFIG_P2P */
             { FUNC(country), CFG_CHANGED_COUNTRY },
             { INT(bss_max_count), 0 },
     diff --git a/wpa_supplicant/config.h b/wpa_supplicant/config.h
     index b889ab8..9cf5468 100644
     --- a/wpa_supplicant/config.h
     +++ b/wpa_supplicant/config.h
     @@ -747,6 +747,16 @@ struct wpa_config {
              ,*     matching network block
              ,*/
             int auto_interworking;
     +
     +       /**
     +        * p2p_go_ht40 - Default mode for HT40 enable when operating as GO.
     +        *
     +        * This will take effect for p2p_group_add and p2p_connect. Note that
     +        * regulatory constraints and driver capabilities are consulted anyway,
     +        * so setting it to 1 can't do real harm
     +        * By default: 0 (disabled)
     +        */
     +       int p2p_go_ht40;
      };
      
      
     diff --git a/wpa_supplicant/config_file.c b/wpa_supplicant/config_file.c
     index 531957a..bd9c17f 100644
     --- a/wpa_supplicant/config_file.c
     +++ b/wpa_supplicant/config_file.c
     @@ -868,6 +868,8 @@ static void wpa_config_write_global(FILE *f, struct wpa_config *config)
                     }
                     fprintf(f, "\n");
             }
     +       if (config->p2p_go_ht40)
     +               fprintf(f, "p2p_go_ht40=%u\n", config->p2p_go_ht40);
      #endif /* CONFIG_P2P */
             if (config->country[0] && config->country[1]) {
                     fprintf(f, "country=%c%c\n",
     diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
     index ba2edff..c9c6826 100644
     --- a/wpa_supplicant/ctrl_iface.c
     +++ b/wpa_supplicant/ctrl_iface.c
     @@ -3117,7 +3117,7 @@ static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
             auth = os_strstr(pos, " auth") != NULL;
             automatic = os_strstr(pos, " auto") != NULL;
             pd = os_strstr(pos, " provdisc") != NULL;
     -       ht40 = os_strstr(pos, " ht40") != NULL;
     +       ht40 = (os_strstr(cmd, "ht40") != NULL) || wpa_s->conf->p2p_go_ht40;
      
             pos2 = os_strstr(pos, " go_intent=");
             if (pos2) {
     @@ -3624,7 +3624,7 @@ static int p2p_ctrl_group_add(struct wpa_supplicant *wpa_s, char *cmd)
             if (pos)
                     freq = atoi(pos + 5);
      
     -       ht40 = os_strstr(cmd, "ht40") != NULL;
     +       ht40 = (os_strstr(cmd, "ht40") != NULL) || wpa_s->conf->p2p_go_ht40;
      
             if (os_strncmp(cmd, "persistent=", 11) == 0)
                     return p2p_ctrl_group_add_persistent(wpa_s, cmd + 11, freq,
     --    
   #+END_SRC

* 常用代码片断
  记录 =wpa_supplicant= 源码中常见的一些代码片断。

** 遍历当前的接口
   #+BEGIN_SRC c
     struct wpa_global *global = wpa_s->global;

     for (wpa_s = global->ifaces; wpa_s; wpa_s = wpa_s->next) {
       if (os_strcmp(wpa_s->ifname, "p2p") == 0) {
         break;
       }
      }
   #+END_SRC

** 遍历接口上存在的SSID
   #+BEGIN_SRC c
     struct wpa_ssid *s;

     for (s = wpa_s->conf->ssid; s; s = s->next) {
       if (s->mode == WPAS_MODE_P2P_GO) {
         ...
       }
      }
   #+END_SRC

** 遍历当前的接口(方法2)
   #+BEGIN_SRC c
     /*
      ,* Check other interfaces to see if they share the same radio. If
      ,* so, they get updated with this same scan info.
      ,*/
     struct wpa_supplicant *ifs, wpa_s;
     ...
     dl_list_for_each(ifs, &wpa_s->radio->ifaces, struct wpa_supplicant,
                      radio_list) {
       if (ifs != wpa_s) {
         wpa_printf(MSG_DEBUG, "%s: Updating scan results from "
                    "sibling", ifs->ifname);
         ...
       }
     }   
   #+END_SRC
* Footnotes
[fn:1] https://w1.fi/wpa_supplicant/devel/index.html
[fn:2] http://lists.shmoo.com/pipermail/hostap/



