#+STARTUP: overview
#+STARTUP: hidestars
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="css/worg.css" type="text/css" />

* 主要API速览   
- =cfg80211_register== 
  这个必须在 =regsiter_netdevice()= 之前调用   
- =cfg80211_connect_result=
  通知上层当前的关联状态。
- =cfg80211_disconnected=
- =cfg80211_get_chandef_type=
- =cfg80211_chandef_create=
- =cfg80211_get_bss=
- =cfg80211_put_bss=
- =cfg80211_inform_bss=
  2.6.31后，优先使用此接口
- =cfg80211_inform_bss_frame=
- =cfg80211_find_ie=
  寻找指定的IE。 如SSID
- =cfg80211_find_vendor_ie=
- =cfg80211_tdls_oper_request=
- =cfg80211_scan_done=
  通知上层，扫描动作停止。
- =cfg80211_rx_mgmt=
  通知上层，接收到未处理的管理帧
- =cfg80211_rx_action=
  通知上层，接收到未处理的Action帧
- =cfg80211_action_tx_status=
  通知上层，Action帧的发送状态
- =cfg80211_new_sta=
  当关联成功后，会调用此接口通知上层添加了新的关联工作站。
  驱动在处理对方的Association Request后，如果成功回应了Association
  Response，会通过该接口通知上层，有新的STA创建。
- =cfg80211_del_sta=
  当Deauth或Diassoc后，会调用些接口。
- =cfg80211_michael_mic_failure=
- =cfg80211_roamed=
- =cfg80211_report_obss_beacon=
- =cfg80211_ibss_joined=
- =cfg80211_ready_on_channel=
  repoort remain on channel ready.
- =cfg80211_remain_on_channel_expired=
- =wiphy_new= 
  会创建 =struct cfg80211_registered_device= 结构实例，并初始化其
  =wdev_list= 链表。这个链表是由 =struct wireless_dev= 类型元素组成。 


* 主要数据结构速览 
- =struct wireless_dev= 
  无线设备的状态， 在 =struct net_device= 的 =ieee80211_ptr= 域中，会
  指向这个数据结构。
- =struct cfg80211_registered_device=
  #+BEGIN_SRC c
    struct cfg80211_registered_device {
            const struct cfg80211_ops *ops;
            struct list_head list;
            /* we hold this mutex during any call so that
             ,* we cannot do multiple calls at once, and also
             ,* to avoid the deregister call to proceed while
             ,* any call is in progress */
            struct mutex mtx;

            /* rfkill support */
            struct rfkill_ops rfkill_ops;
            struct rfkill *rfkill;
            struct work_struct rfkill_sync;

            /* ISO / IEC 3166 alpha2 for which this device is receiving
             ,* country IEs on, this can help disregard country IEs from APs
             ,* on the same alpha2 quickly. The alpha2 may differ from
             ,* cfg80211_regdomain's alpha2 when an intersection has occurred.
             ,* If the AP is reconfigured this can also be used to tell us if
             ,* the country on the country IE changed. */
            char country_ie_alpha2[2];

            /* If a Country IE has been received this tells us the environment
             ,* which its telling us its in. This defaults to ENVIRON_ANY */
            enum environment_cap env;

            /* wiphy index, internal only */
            int wiphy_idx;

            /* associated wireless interfaces */
            struct mutex devlist_mtx;
            /* protected by devlist_mtx or RCU */
            struct list_head wdev_list;
            int devlist_generation, wdev_id;
            int opencount; /* also protected by devlist_mtx */
            wait_queue_head_t dev_wait;

            struct list_head beacon_registrations;
            spinlock_t beacon_registrations_lock;

            /* protected by RTNL only */
            int num_running_ifaces;
            int num_running_monitor_ifaces;

            /* BSSes/scanning */
            spinlock_t bss_lock;
            struct list_head bss_list;
            struct rb_root bss_tree;
            u32 bss_generation;
            struct cfg80211_scan_request *scan_req; /* protected by RTNL */
            struct cfg80211_sched_scan_request *sched_scan_req;
            unsigned long suspend_at;
            struct work_struct scan_done_wk;
            struct work_struct sched_scan_results_wk;

            struct mutex sched_scan_mtx;

    #ifdef CONFIG_NL80211_TESTMODE
            struct genl_info *testmode_info;
    #endif

            struct work_struct conn_work;
            struct work_struct event_work;

            struct cfg80211_wowlan *wowlan;

            struct delayed_work dfs_update_channels_wk;

            /* netlink port which started critical protocol (0 means not started) */
            u32 crit_proto_nlportid;

            /* must be last because of the way we do wiphy_priv(),
             ,* and it should at least be aligned to NETDEV_ALIGN */
            struct wiphy wiphy __aligned(NETDEV_ALIGN);
    };  
  #+END_SRC
- =struct cfg80211_chan_def=
- =struct cfg80211_scan_request=
- =struct cfg80211_ibss_params=
- =struct cfg80211_connect_params=
  Connection parameters
  This structure provides information needed to complete IEEE 802.11
  authentication and association. 

  #+BEGIN_SRC c
    struct cfg80211_ops CFG80211_Ops = {
      ...
      .connect = mt76xx_cfg80211_connect,
      ...
    };

    static int mt76xx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
                                       struct cfg80211_connect_params *sme)
    {
    #ifdef CONFIG_STA_SUPPORT
            RTMP_ADAPTER *pAd;
            INT32 Pairwise;
            INT32 Groupwise;
            INT32 Keymgmt = 0;
            int i;
            CMD_RTPRIV_IOCTL_80211_CONNECT ConnInfo;

            MAC80211_PAD_GET(pAd, wiphy);
            if (!pAd)
                    return -EFAULT;

            CFG80211DBG(RT_DEBUG_TRACE, ("80211> %s ==>\n", __func__));

            //Group Wise
            CFG80211DBG(RT_DEBUG_TRACE, ("Groupwise: %x\n", sme->crypto.cipher_group));
            Groupwise = sme->crypto.cipher_group;

            //Pair Wise
            if (sme->crypto.n_ciphers_pairwise)
                    Pairwise = sme->crypto.ciphers_pairwise[0];
            else
                    Pairwise = 0;
            CFG80211DBG(RT_DEBUG_TRACE, ("Pairwise %x\n", sme->crypto.ciphers_pairwise[0]));

            //Key management
            for (i = 0; i < sme->crypto.n_akm_suites; ++i)
                    Keymgmt |= sme->crypto.akm_suites[i];

            memset(&ConnInfo, 0, sizeof(ConnInfo));

            //WPA Version

            if (!sme->crypto.wpa_versions)
                    ConnInfo.WpaVer = 0;
            else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)
                    ConnInfo.WpaVer = 2;
            else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)
                    ConnInfo.WpaVer = 1;
            else {
                    CFG80211DBG(RT_DEBUG_ERROR, ("version %x not supported\n",
                                                 sme->crypto.wpa_versions));
                    return -ENOTSUPP;
            }
            CFG80211DBG(RT_DEBUG_TRACE, ("wpa_versions %x\n", sme->crypto.wpa_versions));

            /* GeK: [todo] WLAN_AKM_SUITE_PSK and others? */
            CFG80211DBG(RT_DEBUG_TRACE, ("Keymgmt %x\n", Keymgmt));
            if (Keymgmt == WLAN_AKM_SUITE_8021X)
                    ConnInfo.FlgIs8021x = TRUE;
            else
                    ConnInfo.FlgIs8021x = FALSE;

            //Auth type
            CFG80211DBG(RT_DEBUG_TRACE, ("Auth_type %x\n", sme->auth_type));
            if (sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY)
                    ConnInfo.AuthType = Ndis802_11AuthModeShared;
            else if (sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM)
                    ConnInfo.AuthType = Ndis802_11AuthModeOpen;
            else
                    ConnInfo.AuthType = Ndis802_11AuthModeAutoSwitch;

            switch (Pairwise) {
            case 0:
                    CFG80211DBG(RT_DEBUG_TRACE, ("NONE...\n"));
                    ConnInfo.PairwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_NONE;
                    break;
            case WLAN_CIPHER_SUITE_CCMP:
                    CFG80211DBG(RT_DEBUG_TRACE, ("WLAN_CIPHER_SUITE_CCMP...\n"));
                    ConnInfo.PairwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_CCMP;
                    break;
            case WLAN_CIPHER_SUITE_TKIP:
                    CFG80211DBG(RT_DEBUG_TRACE, ("WLAN_CIPHER_SUITE_TKIP...\n"));
                    ConnInfo.PairwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_TKIP;
                    break;
            case WLAN_CIPHER_SUITE_WEP40:
                    /* fall through */
            case WLAN_CIPHER_SUITE_WEP104:
                    CFG80211DBG(RT_DEBUG_TRACE, ("WLAN_CIPHER_SUITE_WEP...\n"));
                    ConnInfo.PairwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_WEP;
                    break;
            default:
                    CFG80211DBG(RT_DEBUG_ERROR, ("pairwise %x not supported\n", Pairwise));
                    return -ENOTSUPP;
            }

            if (Groupwise == WLAN_CIPHER_SUITE_CCMP)
                    ConnInfo.GroupwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_CCMP;
            else if (Groupwise == WLAN_CIPHER_SUITE_TKIP)
                    ConnInfo.GroupwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_TKIP;
            else
                    ConnInfo.GroupwiseEncrypType |= RT_CMD_80211_CONN_ENCRYPT_NONE;

            CFG80211DBG(RT_DEBUG_TRACE, ("ConnInfo.KeyLen ===> %d\n", sme->key_len));
            CFG80211DBG(RT_DEBUG_TRACE, ("ConnInfo.KeyIdx ===> %d\n", sme->key_idx));

            ConnInfo.pKey = (UINT8 *) (sme->key);
            ConnInfo.KeyLen = sme->key_len;
            ConnInfo.pSsid = sme->ssid;
            ConnInfo.SsidLen = sme->ssid_len;
            ConnInfo.KeyIdx = sme->key_idx;
            ConnInfo.bWpsConnection = FALSE;
            /* Check if WPS is triggerred */
            pAd->StaCfg.wpa_supplicant_info.WpaSupplicantUP = WPA_SUPPLICANT_ENABLE;
            if (sme->ie && sme->ie_len &&
                sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM &&
                ConnInfo.PairwiseEncrypType == RT_CMD_80211_CONN_ENCRYPT_NONE) {
                    if (RTMPFindWPSIE(sme->ie, (UINT32) sme->ie_len) != NULL) {
                            ConnInfo.bWpsConnection = TRUE;
                            pAd->StaCfg.wpa_supplicant_info.WpaSupplicantUP
                                    |= WPA_SUPPLICANT_ENABLE_WPS;
                    }
            }

            /* YF@20120328: Use SIOCSIWGENIE to make out the WPA/WPS IEs in AssocReq. */
    #ifdef RT_CFG80211_P2P_CONCURRENT_DEVICE
            if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_CLIENT) {
                    if (sme->ie_len > 0)
                            CFG80211DRV_SetP2pCliAssocIe(pAd, sme->ie, sme->ie_len);
                    else
                            CFG80211DRV_SetP2pCliAssocIe(pAd, NULL, 0);
            } else
    #endif /* RT_CFG80211_P2P_CONCURRENT_DEVICE */
            {
                    if (sme->ie_len > 0)
                            RtmpIoctl_rt_ioctl_siwgenie(pAd, sme->ie, sme->ie_len);
                    else
                            RtmpIoctl_rt_ioctl_siwgenie(pAd, NULL, 0);
            }

    #ifdef DOT11W_PMF_SUPPORT
    #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
            CFG80211DBG(RT_DEBUG_TRACE, ("80211> PMF Connect %d\n", sme->mfp));
            if (sme->mfp)
                    ConnInfo.mfp = TRUE;
            else
                    ConnInfo.mfp = FALSE;
    #endif /* LINUX_VERSION_CODE */
    #endif /* DOT11W_PMF_SUPPORT */

            /* %NULL if not specified (auto-select based on scan) */
            if (sme->bssid != NULL && !MAC_ADDR_EQUAL(sme->bssid, ZERO_MAC_ADDR)) {
                    CFG80211DBG(RT_DEBUG_OFF, ("80211> Connect bssid %02x:%02x:%02x:%02x:%02x:%02x\n",
                                               PRINT_MAC(sme->bssid)));
                    ConnInfo.pBssid = sme->bssid;
            } else
                    ConnInfo.pBssid = NULL;

            RTMP_DRIVER_80211_CONNECT(pAd, &ConnInfo, dev->ieee80211_ptr->iftype);
    #endif /*CONFIG_STA_SUPPORT */
            return 0;
    }                               /* mt76xx_cfg80211_connect */
  #+END_SRC
- =struct cfg80211_pmksa=
- =struct cfg80211_gtk_rekey_data=
- =struct cfg80211_mgmt_tx_params=
- =struct cfg80211_ap_settings=
- =struct cfg80211_beacon_data=
- =struct cfg80211_bitrate_mask=
- =struct cfg80211_ops=
  TODO:  change_station 何时会调用 
- =struct cfg80211_bss=
- =struct cfg80211_crypto_settings=
- =struct ieee80211_iface_combination=
  #+BEGIN_SRC c
    static const struct ieee80211_iface_limit ra_p2p_sta_go_limits[] = 
    {
            {
                    .max = 3,
                    .types = BIT(NL80211_IFTYPE_STATION)| BIT(NL80211_IFTYPE_AP),
            },
            {
                    .max = 1,
                    .types = BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT),
            },
    };
  #+END_SRC
- =struct ieee80211_iface_limit= 
  #+BEGIN_SRC c
    static const struct ieee80211_iface_combination 
    ra_iface_combinations_p2p[] = {
            {
                    .num_different_channels = 1,
                    .max_interfaces = 3,
                    //.beacon_int_infra_match = true,
                    .limits = ra_p2p_sta_go_limits,
                    .n_limits = 1,//ARRAY_SIZE(ra_p2p_sta_go_limits),
            },
    };

    static const struct ieee80211_iface_combination 
    ra_iface_combinations_p2p_GO[] = {
            {
                    .num_different_channels = 1,
                    .max_interfaces = 3,
                    //.beacon_int_infra_match = true,
                    .limits = ra_p2p_sta_go_limits,
                    .n_limits = ARRAY_SIZE(ra_p2p_sta_go_limits),
            },
    };
  #+END_SRC

  在调用 =wiphy_register= 之前，可以将上述信息设置到 =struct wiphy= 的
  =iface_combinations= 和 =n_iface_combinations= 。
- =struct ieee80211_mgmt=  
  管理帧，相关API有：
  - =ieee80211_is_mgmt=

  - =ieee80211_is_probe_resp=

  - =ieee80211_is_disassoc=

  - =ieee80211_is_deauth=

  - =ieee80211_is_action=

  - =cfg80211_rx_mgmt=
    向上层报告有未处理的管理帧收到。
- =struct cfg80211_bss=
  BSS信息
- =struct station_info=
  描述STA相关的信息， 其中 =filled= 可以告知 =nl80211= 层，上报上来的
  消息包含哪些IE。 如 =STATION_INFO_ASSOC_REQ_IES= 表明当前上报上来的
  Association Request会包含相关的IE信息。
  #+BEGIN_SRC c
    VOID CFG80211OS_NewSta(IN PNET_DEV pNetDev, IN const PUCHAR mac_addr, IN const PUCHAR assoc_frame, IN UINT32 assoc_len)
    {
            struct station_info sinfo;
            struct ieee80211_mgmt *mgmt;

            NdisZeroMemory(&sinfo, sizeof(sinfo));

            sinfo.filled = STATION_INFO_ASSOC_REQ_IES;

            mgmt = (struct ieee80211_mgmt *) assoc_frame;
            sinfo.assoc_req_ies_len = assoc_len - 24 - 4;
            sinfo.assoc_req_ies = mgmt->u.assoc_req.variable;

            return cfg80211_new_sta(pNetDev, mac_addr, &sinfo, GFP_KERNEL);
    }  
  #+END_SRC


* 主要流程
** 数据结构
   - =struct wiphy=
     wireless hardware description
   - =wireless_dev=
     wireless device state
   - =struct net_device_ops=
     在Linux 2.6.31内核版本后，在注册设备时，如下几个回调接口一般需要
     被定义：
     1. =ndo_open=
     2. =ndo_stop=
     3. =ndo_start_xmit=
     4. =ndo_do_ioctl=
     5. =ndo_get_stats=
        可选，获取状态信息
     6. =ethtool_ops=
        获取驱动信息的回调函数
     7. =ndo_validate_addr=
   - =struct net_device_stats=
   - =struct ieee80211_rate=
     支持的速率定义
   - =struct ieee80211_channel=
     信道定义, =IEEE80211_CHAN_RADAR= 用于判断当前信道是否需要回避雷达。
   - =struct ieee80211_supported_band=
     频段定义：2.4G(=IEEE80211_BAND_2GHZ=), 5G(=IEEE80211_BAND_5GHZ=)等 
** 频段和速率的定义
   1. 信道定义的定义
      =center_freq, hw_value, max_power, max_antenna_gain= 这个值的定
      义。需要用到信道与频率之间的映射函数： =ieee80211_channel_to_frequency=
   2. 初始化所支持的速率
      定义 =struct ieee80211_rate= 数组
   3. 频段定义
      包含的信息有：支持的信道数，支持的速率，以及HT Capability相关信
      息。

** 设备注册    
- =wiphy_new=  
  Allocate wiphy and hook cfg80211 ops
- =wiphy_register=  
  Register the wiphy to cfg80211. Do sanity checking , set up
  regulatory info according to the wiphy info and so on.
- =wiphy_free=  
  Free the allocated wiphy
- =wiphy_unregister=  
  Unregister the wiphy.
  
在注册 =netdev= 之前进行，主要包含硬件的一些能力信息：
1. bands and channels
2. bitrates per band
3. HT capabilites
4. supported interface modes
netdev结构的 =ieee80211 ptr= 指针指向注册的 =struct wireless_dev= 对象 。

#+BEGIN_SRC c
  /**
   ,* 注册一个wireless device的过程
   ,*/

  static struct wireless_dev *CFG80211_WdevAlloc(
          IN CFG80211_CB                                  *pCfg80211_CB,
          IN CFG80211_BAND                                *pBandInfo,
          IN VOID                                                 *pAd,
          IN struct device                                *pDev)
  {
          struct wireless_dev *pWdev;
          ULONG *pPriv;


          /*
           ,* We're trying to have the following memory layout:
           ,*
           ,* +------------------------+
           ,* | struct wiphy                       |
           ,* +------------------------+
           ,* | pAd pointer                        |
           ,* +------------------------+
           ,*/
          pWdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);


          //struct cfg80211_ops
          pWdev->wiphy = wiphy_new(&CFG80211_Ops, sizeof(ULONG *)); 

          /* keep pAd pointer, Your Private data */
          pPriv = (ULONG *)(wiphy_priv(pWdev->wiphy));
          ,*pPriv = (ULONG)pAd;

          set_wiphy_dev(pWdev->wiphy, pDev);

          //设置wiphy相关的域
          pWdev->wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;

          //初始化Channel信息
          /*
           ,* struct wiphy
           ,* struct ieee80211_channel
           ,* struct ieee80211_rate
           ,* struct ieee80211_supported_band
           ,*/


          wiphy_register(pWdev->wiphy);

          
  }


  BOOLEAN CFG80211_Register(
          IN VOID                                         *pAd,
          IN struct device                        *pDev,
          IN struct net_device            *pNetDev)
  {
          CFG80211_CB *pCfg80211_CB = NULL;
          CFG80211_BAND BandInfo;


          /* allocate MAC80211 structure */
          os_alloc_mem(NULL, (UCHAR **)&pCfg80211_CB, sizeof(CFG80211_CB));

          ...
          /* allocate wireless device */
          RTMP_DRIVER_80211_BANDINFO_GET(pAd, &BandInfo);

          pCfg80211_CB->pCfg80211_Wdev = \
                                  CFG80211_WdevAlloc(pCfg80211_CB, &BandInfo, pAd, pDev);
          ...
            
          pNetDev->ieee80211_ptr = pCfg80211_CB->pCfg80211_Wdev;
          SET_NETDEV_DEV(pNetDev, wiphy_dev(pCfg80211_CB->pCfg80211_Wdev->wiphy));
          pCfg80211_CB->pCfg80211_Wdev->netdev = pNetDev;

          ...
            
          CFG80211DBG(RT_DEBUG_ERROR, ("80211> CFG80211_Register\n"));
          return TRUE;
  } /* End of CFG80211_Register */

#+END_SRC

#+TITLE：注册网络设备相关函数
#+BEGIN_SRC c
  struct net_device *device = alloc_etherdev(privDataSize);

  struct net_device_ops *pNetDevOps = NULL;

  device->netdev_ops = pNetDevOps;

  //分配一个接口名
  dev_get_by_name(...)

  //cfg80211 register

  //注册
  if (rtnl_locked)
    ret = register_netdevice(pNetDev);
  else
    ret = register_netdev(pNetDev);


#+END_SRC

** regulatory enforcement  
   Channel使用信息, 管制
   =regulatory_init=

** station management  
   添加，移除和修改STA。
   Dump STA列表
   主要的回调接口：
   - =.add_ station=
   - =.del_station=
   - =.change_station=
   - =.get_station=
   - =.dump_station=

** mesh management
   mesh路径处理
   读取或设置mesh参数 

** virtual interface management
   - 创建虚拟接口和移除虚拟接口
   - 改变虚拟接口的类型
   - 改变 =monitor= 标记
   - 跟踪与无线设备关联的接口


   
* 几个主要数据结构之间的关系   
  [[./images/2016/2016012801.png]]

wireless_send_event

* MAC80211
  
** 主要API速览

*** =ieee80211_check_tim()=
    checks a specific information element (TIM)
    The TIM is an array of 2008 entries. Because the TIM size is 251
    bytes (2008 bits) 

*** =ieee80211_get_buffered_bc()=
    retrieve packets from the multicast/broadcast buffer

*** =sta_info_insert=
    Adds a station

*** =sta_info_destroy_addr=
    Removes a station

*** =sta_info_get=
    Fetches a station; the address of the station (it’s bssid) is
    passed as a parameter. 

*** =ieee80211_rate_control_register=
    注册速率控制算法
** MLME
   
*** 扫描
    =ieee80211_send_probe_req()=
    ==>
    =the ieee80211_request_scan()=

    Change Channel:
    =ieee80211_hw_config()=

    Channel to Frequence Transition: 
    =ieee80211_channel_to_frequency()=

*** 认证
    =the ieee80211_send_auth()=

    有两种类型的认证方式：
    1. =WLAN_AUTH_OPEN=
    2. =WLAN_AUTH_SHARED_KEY=

*** 关联
    =ieee80211_send_assoc()=

*** 重新关联
    =ieee80211_send_assoc()=

** mac80211实现
   
*** 数据结构
    1. =ieee80211_hw=
       代表硬件信息
    2. =ieee80211_ops=
       实例传递给 =ieee80211_alloc_hw()= 方法，这个实际定义了一些回调
       函数 ：
       - =tx()=
         The transmit handler called for each transmitted packet. It
         usually returns =NETDEV_TX_OK= (except for under certain
         limited conditions). 
       - =start()=
         开户数据帧的接收
       - =stop()=
         停止数据帧的接收，关闭硬件
       - =add_interface()=
         Called when a network device attached to the hardware is
         enabled. 
       - =remove_interface()=
         Informs a driver that the interface is going down. 
       - =config()=
         Handles configuration requests, such as hardware channel
         configuration. 
       - =configure_filter()=
         Configures the device’s Rx filter.

*** Rx Path
    主要的接收函数 =ieee80211_rx()=
    对接收到的数据，会进行一些检查，可能会丢弃一些数据包：
    #+BEGIN_SRC c
      ieee80211_rx_h_mgmt_check(struct ieee80211_rx_data *rx)
      {
        struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;
        struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);
        . . .
          if (rx->skb->len < 24)
            return RX_DROP_MONITOR;
          if (!ieee80211_is_mgmt(mgmt->frame_control))
            return RX_DROP_MONITOR;
          . . .
      }    
    #+END_SRC

*** Tx Path
    主要的发送函数 =ieee80211_tx()=
    
*** Packet Aggregation
    1. =ieee80211_start_tx_ba_session()=
       The originator starts the block acknowledgement session
       ADDBA Request
    2. =ieee80211_send_addba_resp()=
       ADDBA response
    3. =ieee80211_send_bar()=
       sends a Block Ack Request (BAR) packet
    4. =ieee80211_send_delba()=
       DELBA request

* 参考
  [1] http://linuxwireless.org/en/users/Documentation/
