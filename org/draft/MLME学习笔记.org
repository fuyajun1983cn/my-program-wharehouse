#+STARTUP: overview
#+STARTUP: hidestars
#+OPTIONS:    H:3 num:nil toc:t \n:nil ::t |:t ^:t -:t f:t *:t tex:t d:(HIDE) tags:not-in-toc
#+HTML_HEAD: <link rel="stylesheet" title="Standard" href="css/worg.css" type="text/css" />

* MLME总体分析

** 概述

*** 处理接收到的管理帧 =STAHandleRxMgmtFrame rtmp_data.c=
    
** 附加信息
   - pAd->ApCfg.MBSSID[] is the main structure for restoring BSS info
     of P2P GO/SoftAP (BSSID, key, beacon content)
   - CFG80211_OpsKeyAdd(), CFG80211_OpsKeyDel() are the functions in driver for maintaining security keys
   - CFG80211DRV_OpsBeaconSet() is called while
     - hostapd starts the SoftAP on uap0
     - Wpa_supplicant starts P2P GO on p2p0
   - BeaconUpdateExec() is called periodically for updating TIM IE in beacon
   - CFG80211_PacketSend() is hooked as the Tx entry function while initializing a virtual interface
   - APHandleRxMgmtFrame(), handle management frame such as broadcast
     probe request.
   - get_netdev_from_bssid() is called for recognizing an Rx packet is belonging to which net device (ra0, p2p0, or uap0)
   - MacTableReset() and AsicDelWcidTab() are called while AP-liked interface is starting or stopping
     - The entry for the already connected STAs of P2P GO or SoftAP will be flushed and then disconnect

** 将数据包发往上层处理
   在 =cmm_mat.c= 中有定义 =MATProtoTb= ，用于相关协议数据包
* MLME主循环处理
  MLME的主循环处理函数是:  =MlmeHandler= 
     
** 消息入队和出队接口
    主要是通过 调用  =MlmeEnqueue= 和 =MlmeDequeue= 来将消息添加或从队
    列中删除。
    
** 重要函数
   
*** MlmeEnqueueForRecv
    This function is used when Recv gets a MLME message

*** MlmePeriodicExec
    周期性执行的一个函数。

* MLME状态机

** APCLI状态机
   p2p时使用的状态机
   
** AP状态机

*** AP_AUTH state machine
     Handle authentication/de-authentication packets

*** AP_ASSOC state machine 
    Handle association/re-association/disassociation packets

*** AP_SYNC state machine 
    Handle beacon or scan behavior

** STA状态机
   STA时使用的状态机
*** CTNL
    CNTL sends messages to other state machine to trigger actions
    Control STA connection behavior
    总共有8个状态：
    1. =CNTL_WAIT_OID_LIST_SCAN=
    2. =CNTL_WAIT_ASSOC=
    3. =CNTL_WAIT_AUTH2=
    4. =CNTL_WAIT_AUTH=
    5. =CNTL_WAIT_JOIN=
    6. =CNTL_WAIT_DISASSOC=
    7. =CNTL_WAIT_OID_DISASSOC=
    8. =CNTL_IDLE=

    处理函数 MlmeCntlMachinePerformAction 

*** SYNC
    Handle scan or join BSS behavior
    总共有3个状态：
    1. =SCAN_LISTEN=
    2. =JOIN_WAIT_BEACON=
    3. =SYNC_IDLE=

    MlmeJoinReqAction --> PeerBeaconAtJoinAction --> CntlWaitAuthProc
    (send auth req, waiting for auth response)

IE_EXT_CAPABILITY

*** AUTH
    Handle authentication packets
    总共有3个状态：
    1. =AUTH_WAIT_SEQ4=
    2. =AUTH_WAIT_SEQ2=
    3. =AUTH_REQ_IDLE=

*** ASSOC 
    Handle association/re-associate/disassociation packets
    总共有2个状态：
    1. =ASSOC_IDLE=
    2. =ASSOC_WAIT_RSP=

* 数据接收

** 基本函数调用流程
   #+BEGIN_SRC plantuml :file ./images/2016/2016032499.png :cmdline -charset UTF-8
     title mt76xx驱动数据接收流程
     @startuml
     start
     :RTUSBBulkReceive;
     :rtmp_rx_done_handle;
     note right: 代码位于wdev_rx.c文件中
     if (是数据帧) then(yes)
     #Blue:dev_rx_data_frm;
     else
     if (是管理帧) then(yes)
     #Red :dev_rx_mgmt_frm;
     else
     if (是控制帧) then(yes)
     #Green :dev_rx_ctrl_frm;
     endif
     endif
     endif
     stop
     @enduml   
   #+END_SRC

   #+RESULTS:
   [[file:./images/2016/2016032499.png]]

   APRxDataFrameAnnounce (mt76x2 ap)
   STAHandleRxDataFrame (mt76x2 sta)
   rx_data_frm_announce (mt7603)

* 数据发送
  
** 概述

   deq_mgmt_frame

   MiniportMMRequest(发送管理帧给AP) --> MlmeHardTransmit --> MlmeHardTransmitMgmtRing --> RtmpUSBMgmtKickOut

   STASendPacket_New --> rtmp_enq_req


   在函数 RTMPDeQueuePacket 中，会处理加入到发送队列中的需要传输的数据
   包。
   
   数据结构： _TX_BLK, 触发硬件进行数据发送的函数是： HAL_KickOutTx

   驱动注册的Callback函数为：STAHardTransmit (硬件数据包传送)

   而这一切，是从 =struct net_device_ops= 中的回调接口
   =ndo_start_xmit= 触发的。

* 问题调试

** 读取TX RX寄存器状态
   正常情况下，值应该为0x0c
   #+BEGIN_SRC c
     UINT32 Value;
     RTMP_IO_READ32(pAd, 0x1004, &Value);
     Value = Value | 0x0c; /* set bit[30]=1 */
     RTMP_IO_WRITE32(pAd, 0x1004, Value); 
   #+END_SRC

** Dump Debug Register Values
    #+BEGIN_SRC c
      /* Dump Debug Register Values */
      INT Set_Register_Dump(IN PRTMP_ADAPTER pAd, IN PSTRING arg)
      {

              UINT32 Value = 0;

              /* Toggle Error */
              DBGPRINT(RT_DEBUG_OFF, ("--dump_registers:--\n"));
              read_reg(pAd, 0x40, 0x2820, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2820: 0x%x\n", Value));
              /* Reset to default */
              /* write_reg(ad, 0x40, 0x2820, 0x1); */
              read_reg(pAd, 0x40, 0x023C, &Value); //common register
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_023C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x024c, &Value); //PCIE_REMAP_BASE4 default: 0x0
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_024C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0254, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0254: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1500, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1500: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1504, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1504: 0x%x\n", Value));
      #ifdef RTMP_MAC_USB
              read_reg(pAd, 0x40, 0x9018, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_9018: 0x%x\n", Value));
              if (Value == 0x0)
                      DBGPRINT(RT_DEBUG_OFF, ("UDMA not enabled\n"));
      #endif
              read_reg(pAd, 0x40, 0x9100, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_9100: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x9110, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_9110: 0x%x\n", Value));

              read_reg(pAd, 0x40, 0x2140, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2140: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2240, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2240: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2280, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2280: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2290, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2290: 0x%x\n", Value));
              DBGPRINT(RT_DEBUG_OFF, ("\n"));

              read_reg(pAd, 0x41, 0x1004, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1004: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1200, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1200: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0A38, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0A38: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0A30, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0A30: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0A34, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0A34: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0A0C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0A0C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09C4, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09C4: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09E0, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09E0: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09E8, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09E8: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09F0, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09F0: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09F4, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09F4: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09F8, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09F8: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09FC, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09FC: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x15F4, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_15F4: 0x%x\n", Value));

              read_reg(pAd, 0x41, 0x080c, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_080c: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1700, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1700: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1704, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1704: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x1708, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_1708: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x170C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_170C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0430, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0430: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0434, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0434: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0438, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0438: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x043C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_043C: 0x%x\n", Value));
              /* FCE */
              read_reg(pAd, 0x41, 0x0800, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0800: 0x%x\n", Value));
              if (Value == 0x0)
                      DBGPRINT(RT_DEBUG_OFF, ("FCE not enabled\n"));
              DBGPRINT(RT_DEBUG_OFF, ("\n"));

              /* FW Traffic to Host or not */
              read_reg(pAd, 0x41, 0x0A0C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0A0C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x080c, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_080c: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0810, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0810: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0814, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0814: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0818, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0818: 0x%x\n", Value));

              read_reg(pAd, 0x41, 0x0988, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0988: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x098C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_098C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x0998, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_0998: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x099C, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_099C: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09a8, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09a8: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09ac, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09ac: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09b8, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09b8: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0x09bc, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_09bc: 0x%x\n", Value));
              DBGPRINT(RT_DEBUG_OFF, ("\n"));

              /* USB IP CRs */
              read_reg(pAd, 0x40, 0x2244, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2244: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2254, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2254: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2264, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2264: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2274, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2274: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2284, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2284: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x2294, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_2294: 0x%x\n", Value));
              read_reg(pAd, 0x40, 0x80, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x40_80: 0x%x\n", Value));

              read_reg(pAd, 0x41, 0xa10, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a10: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa14, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a14: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa18, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a18: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa1c, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a1c: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa20, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a20: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa24, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a24: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa28, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a28: 0x%x\n", Value));
              read_reg(pAd, 0x41, 0xa2c, &Value);
              DBGPRINT(RT_DEBUG_OFF, (" 0x41_a2c: 0x%x\n", Value));

              /* RTUSBReadMACRegister(pAd, 0x738, &Value); */
              read_reg(pAd, 0x41, 0x738, &Value);
              DBGPRINT(RT_DEBUG_ERROR, ("F/W Heart beat(0x738): 0x%x\n", Value));

              DBGPRINT(RT_DEBUG_OFF, ("\n"));
              return 0;
      }
          
    #+END_SRC
** 设置HT Bandwidth
   #+BEGIN_SRC c
     //pAd->ScanTab.BssEntry[bss_idx].Channel
     bbp_set_bw(pAd, BW_20)
   #+END_SRC

** p2p client连接流程
    在p2p协商完成后，会开始WPS过程，这个过程会涉及关联
    入口函数：
    1. mt76xx_cfg80211_connect
       cfg80211_ops中的connect回调函数。
    
    2. CFG80211DRV_P2pClientConnect
       #+BEGIN_SRC c
         pAd->cfg80211_ctrl.FlgCfg80211Connecting = TRUE;
         Set_ApCli_Ssid_Proc(pAd, (PSTRING) Connect_SSID);
         Set_ApCli_Enable_Proc(pAd, "1");
         CFG80211DBG(RT_DEBUG_OFF, ("80211> APCLI CONNECTING SSID = %s\n", Connect_SSID));
       #+END_SRC
    3. STAMlmePeriodicExec
       #+BEGIN_SRC c
         /* YF_TODO */
         #if defined(P2P_SUPPORT) || defined(RT_CFG80211_P2P_CONCURRENT_DEVICE)
         if (RTMP_CFG80211_VIF_P2P_CLI_ON(pAd)) {
           ...
           if (pAd->Mlme.OneSecPeriodicRound % 2 == 1)
             ApCliIfUp(pAd);
           ...
             }
         #endif /* P2P_SUPPORT || RT_CFG80211_P2P_CONCURRENT_DEVICE */              
       #+END_SRC
    4. ApCliIfUp
       #+BEGIN_SRC c
         if (APCLI_IF_UP_CHECK(pAd, ifIndex)
             && (pApCliEntry->Enable == TRUE)
             && (pApCliEntry->Valid == FALSE)
         #ifdef APCLI_CONNECTION_TRIAL
             && (ifIndex == 0)
         #endif /* APCLI_CONNECTION_TRIAL */
             ) {
           DBGPRINT(RT_DEBUG_TRACE,
                    ("(%s) ApCli interface[%d] startup.\n", __func__, ifIndex));
           MlmeEnqueue(pAd, APCLI_CTRL_STATE_MACHINE, APCLI_CTRL_JOIN_REQ, 0, NULL,
                       ifIndex);
          }
                
       #+END_SRC
    5. ApCliCtrlJoinReqAction

** dump发往上层的数据
    #+BEGIN_SRC c
      static void check_packet_loss_for_rtp(IN PRTMP_ADAPTER  pAd,  
                                                     IN PNDIS_PACKET          pPacket)
      {
              UCHAR *data = NULL;
              USHORT *eth_type;

              DBGPRINT(RT_DEBUG_ERROR, ("check_packet_loss_for_rtp\n"));

              data = GET_OS_PKT_DATAPTR(pPacket);
      #if 0
              if (OS_NTOHS(get_unaligned((USHORT*)(data + 12))) == 0x0800)
              {
                      DBGPRINT(RT_DEBUG_ERROR, ("%s::IP Packet\n", __FUNCTION__));
              }
      #endif
              eth_type = (USHORT *)&data[12];
              DBGPRINT(RT_DEBUG_ERROR, ("eth_type : 0x%04x\n", OS_NTOHS(get_unaligned(eth_type))));
              if (*eth_type == cpu_to_be16(ETH_P_IP))  {//IP Header
                      INT ip_h_len;
                      UCHAR *ip_h;
                      UCHAR *udp_h;
                      UCHAR *rtp_h;
                      USHORT udp_len;
                      USHORT src_port = 0;
                      USHORT dest_port = 0;
                      USHORT rtp_seqNum = 0;
                      static USHORT last_rtp_seqNum = 0;

                      DBGPRINT(RT_DEBUG_ERROR, (">Receive IP Packet\n"));
                  
                      ip_h = data + 14;
                      ip_h_len = (ip_h[0] & 0x0f)*4;
                      
                      if (ip_h[9] == 0x11)  {/* UDP */
                              DBGPRINT(RT_DEBUG_ERROR, (">>Receive UDP Packet\n"));
                              udp_h = ip_h + ip_h_len;        
                              
                              memcpy(&src_port, udp_h, 2);
                              src_port = ntohs(src_port);
                              memcpy(&dest_port, udp_h + 2, 2);
                              dest_port = ntohs(dest_port);
                              DBGPRINT(RT_DEBUG_TRACE, (">>UDP source port: %d, dest port: %d\n", src_port, dest_port));
                              memcpy(&udp_len, udp_h + 4, 2);
                              udp_len = ntohs(udp_len);
                              if (udp_len > 20) {
                                      rtp_h = udp_h + 8;
                                      if (rtp_h[1] == 0x80 && rtp_h[0] == 0x21) {//RTP
                                      
                                              memcpy(&rtp_seqNum, rtp_h + 2, 2);
                                              rtp_seqNum = ntohs(rtp_seqNum);
                                              if (last_rtp_seqNum != 0 && last_rtp_seqNum + 1 != rtp_seqNum) {
                                                      DBGPRINT(RT_DEBUG_ERROR, (">>>Lost Sequence %d, Current Sequence: %d!!!\n", last_rtp_seqNum + 1 , rtp_seqNum));
                                              } 
                                               last_rtp_seqNum = rtp_seqNum;
                                      }
                              }
                              
                      }else if (ip_h[9] == 0x06) {
                              DBGPRINT(RT_DEBUG_ERROR, (">>Receive TCP Packet\n"));
                      } else if (ip_h[9] == 0x01) {
                              DBGPRINT(RT_DEBUG_TRACE, (">>Receive ICMP Packet\n"));
                      }
                      
              }else if (*eth_type == cpu_to_be16(ETH_P_ARP)) {
                      DBGPRINT(RT_DEBUG_TRACE,(">Receive a ARP Packet\n"));
              } else if (*eth_type == cpu_to_be16(0x888e)) {
                      DBGPRINT(RT_DEBUG_TRACE,(">Receive a EAPOL Packet\n"));
              }
              
      }    
    #+END_SRC

** 发送速率调整
    APMlmeDynamicTxRateSwitching

    ref: http://blog.csdn.net/junglefly/article/details/48974077

    http://www.theruckusroom.net/2015/05/all-other-factors-of-which-there-are-many-being-equal-stronger-signal-strength-is-correlated-with-higher-data-transfer-sp.html

** 判断当前是否处于2.4G信道
   #+BEGIN_SRC c
     if (pAd->LatchRfRegs.Channel <= 14) {
       ...
      }

     //当前已经连接的Channel
     pAd->CommonCfg.Channel
   #+END_SRC

** 判断当前TX Queue是否为空
    #+BEGIN_SRC c
      if (mt76x2_polling_txq_empty(pAd) != STATUS_SUCCESS)    {
        DBGPRINT(RT_DEBUF_OFF, ("Tx buffer has data"))
       }
    #+END_SRC

** 查询或设置当前Driver状态
    #+BEGIN_SRC c
      RTMP_TEST_FLAG(...)
      RTMP_SET_FLAG(...)

      OPSTATUS_TEST_FLAG(...)
      OPSTATUS_SET_FLAG(...)
    #+END_SRC
